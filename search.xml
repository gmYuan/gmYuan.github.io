<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络之 XSS + CSRF详解]]></title>
    <url>%2F2020%2F03%2F08%2F%E7%BD%91%E7%BB%9C%E4%B9%8B-XSS-CSRF%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍了XSS和CSRF 相关知识点。 目录 1 预读文档 2 XSS相关 3 CSRF相关 一 预读文档 01 寒冬求职之你必须要懂的Web安全 02 前端安全系列（一）：如何防止XSS攻击 03 前端安全系列之二：如何防止CSRF攻击 阅读原因: 直接 参考文档 二 XSS相关 1 Q: 什么是 XSS A: S1 跨站脚本攻击 + 攻击者 注入恶意的 html标签/JS代码，从而获取用户信息等内容; S2 XSS的本质是：恶意代码未经过滤 + 浏览器无法区分哪些脚本是可信的，导致恶意脚本被执行 2 Q: XSS的类型有哪些 A: S1 反射型: 如 搜索 + href/src等跳转属性 + POST参数 攻击者构造出特殊的 URL，其中包含恶意代码 =&gt; 服务端将恶意代码从 URL 中取出，在响应内容中 包含这段XSS代码 =&gt; 返回给浏览器 解析执行 S2 存储型: 如 评论功能 攻击者提交一段XSS代码 =&gt; 服务器端接收并存储 =&gt; 其他用户访问这个接口内容时，都会执行这段恶意代码 S3 DOM型：如 onload/onerror等事件 攻击者构造出特殊数据，其中包含恶意代码 =&gt; 前端JS 解析执行了 URL 中的恶意代码 它属于 前端JS自身的 安全漏洞 3 Q: 如何防御 XSS A: S1 对明确的输入类型，进行 格式检查： 如 邮箱/ 电话号码等; S2 对 HTML标签+JS代码 进行编码转义, 要在不同的上下文里, 使用相应的转义规则： 如 HTML标签 文字内容/ HTML标签 属性值/ HTML标签 内联监听器/ CSS属性值/ CSS的URL/ URL路径/ URL参数 S3.1 尽量避免使用 .innerHTML/ .outerHTML/ document.write()/ eval()/ S3.2 尽量避免使用 DOM中的 内联事件监听器, 如 onerror/ onload S4 开启CSP：禁止加载外域代码/ 禁止外域提交 123Content-Security-Policy: default-src 'self'&lt;meta http-equiv="Content-Security-Policy" content="form-action 'self';"&gt; S5 开启 HttpOnly属性 三 CSRF相关 1 Q: 什么是 CSRF A: S1 跨站请求伪造： 攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站 发送跨站请求 S2 典型的 CSRF攻击流程： (1) 受害者登录 A站点，并保留了 登录凭证(Cookie); (2) 攻击者诱导受害者访问了 站点B (3) 站点B 向 站点A 发送请求 + 浏览器会默认携带 站点A的 Cookie信息; (4) 站点A执行了 站点B的请求 2 Q: CSRF的 攻击特点是什么 A: S1 攻击一般发起在 第三方网站; S2 攻击者并不能获取到受害者的 登录凭证，仅仅是 “冒用” (cookie有同源策略); S3 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交 根据这3个特点，就可以制定 CSRF的防御策略 3 Q: 如何防御 CSRF A: S1 同源检测： 用 Origin Header / Referer Header:same-origin确定 来源域名 + 如果 Origin和Referer都不存在，直接进行阻止 S2 添加验证码: 体验不够好，但是在关键敏感步骤时 可以使用 S3 使用Token: (1) 服务端给用户 生成一个token，加密后传给用户 (2) 用户在提交请求时，需要携带 这个token (3) 服务端 验证token是否正确 S4 Samesite Cookie属性: Set-Cookie响应头新增Samesite属性: Strict/Lax 123Set-Cookie: foo=1; Samesite=StrictSet-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3]]></content>
      <categories>
        <category>XSS CSRF</category>
      </categories>
      <tags>
        <tag>XSS CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络之 cookie+session+token详解]]></title>
    <url>%2F2020%2F03%2F05%2F%E7%BD%91%E7%BB%9C%E4%B9%8B-cookie-session-token%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言本文实现了 cookie、session、token相关知识点。 目录: 1 预读文档 2 Cookie相关 3 Session相关 4 Token相关 一 预读文档 1 傻傻分不清之 Cookie、Session、Token、JWT 2 把cookie聊清楚 阅读原因: 直接 参考文档 二 Cookie相关 Q1: 什么是 Cookie A: S1 HTTP 是一个 无状态的协议，每个请求都完全独立，服务端不会记录之前通信 的任何信息; S2 为了能够记录 服务器和浏览器之间的会话状态，引入了cookie机制; S3.1 当浏览器第一次向 服务器发起请求时,服务器会把 cookie放在 响应请求中 返回给浏览器; S3.2 当浏览器再次发起请求时，就会自动携带上之前的cookie信息 发送给服务端; S3.2 服务端通过查看 cookie信息, 就可以获取到 之前记录的 信息内容 S4 所以，cookie的主要作用是: 身份识别 和 信息记录 Q2: 如何创建cookie A: S1 服务端通过 set-cookie响应头字段 设置cookie; S2 浏览器通过 document.cookie API来 创建cookie Q3: cookie对象有哪些属性 A: S1 name: 表示cookie的名字; S2 value: 表示cookie的值; S3 domain: 指定 cookie所属域名; S4 path: 指定 cookie在哪个路由 下生效; S5 Expires: 设置的 cookie过期时间, 根据的是本地时间所以不精确; S6 maxAge: 设置的 cookie失效时间; S7 secure: 设置 仅在安全协议下 cookie才生效; S8 httpOnly: 无法通过 JS脚本 读取到 cookie信息, 能够 防止xss攻击 Q4: Cookie有哪些缺点: A: S1 明文传输，不够安全: 不要存储敏感数据 + 注意设置httpOnly S2 容量不够大: 一般只有4KB大小; S3 有跨域限制 S4 移动端对 cookie 的支持不是很好 S5 过多的Cookie 会影响性能: 每次请求都会携带cookie, 包括静态资源请求，会造成资源浪费 三 Session相关 Q1: 什么是 Session A: S1 Session是另一种 会话状态记录的 机制, 基于cookie实现 S2.1 浏览器第一次向 服务器发起请求时, 服务器会根据 用户提交的信息，生成对应的 Session, 然后把对应的SessionID标识 返回给浏览器; S2.2 浏览器接收到 SessionID后，会把它存入到 Cookie中，同时记录 此SessionID 属于哪个域名; S3.1 当第二次访问服务器时，会通过 Cookie把 SessionID传回给 服务端; S3.3 服务端根据 SessionID查找对应的 Session信息—— 找到: 用户已登录; 未找到： 用户没有登录/ 登录失效 Q2: Session 有哪些缺点: A: S1 session存储在服务器里面，数量过多时会 影响服务端性能 S2 会有 session共享问题需要解决 S3 因为基于cookie，所以同样有 有跨域限制 + 移动端支持不友好 Q3: Cookie 和 Session 的区别 A: S1 存储方式不同: cookie信息保存在客户端中 + Session信息保存在 服务端中; S2 安全性不同: 由S2可知，Session比Cookie更安全; S3 容量大小不同: cookie一般大小是4KB + Session容量大得多; S4 存储的 值类型不同: Cookie只支持存字符串数据 + Session可以存任意 数据类型 S5 有效期不同: Cookie可设置为长时间保持，如默认登录功能 + Session一般 失效时间较短 Q4: 如果禁止了 Cookie，如何实现 会话状态记录 A: S1 重写URL: 在请求的地址后面拼接 xxx?SessionID=123456 S2 使用token: token也可以用于 状态记录 四 Token相关 Q1: 什么是 Token A: S1 token是 访问特定资源接口API时 所使用的 资源凭证 S2 客户端使用 用户名跟密码 请求登录; S3 服务端 验证用户名与密码 =&gt; 成功后，服务端生成一个 token + 把这个 token发送给客户端 S4 客户端收到 token以后，把它存储起来 + 每次向服务端请求资源的时， 通过header发送 token S5 服务端收到请求，验证token + 验证成功，就向客户端 返回请求的数据 Q2: Token的特点 A: S1 基于 token的 用户认证是一种 服务端无状态的认证方式 =&gt; 减轻服务器的压力 S2 token应用管理，所以可以 避开同源策略 S3 token可以避免 CSRF攻击 S4 token更加适用于 移动端]]></content>
      <categories>
        <category>cookie session token</category>
      </categories>
      <tags>
        <tag>cookie session token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器机制之 Event Loop]]></title>
    <url>%2F2020%2F03%2F02%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6%E4%B9%8B-Event-Loop%2F</url>
    <content type="text"><![CDATA[前言本文介绍了 Event Loop 的相关知识点。 目录: 1 预读文档 2 浏览器 进程与线程 3 JS的运行机制—— Event Loop 4 NodeJS 的Event Loop 1 预读文档 1 浏览器与Node的 事件循环有何区别 阅读原因: Node.js部分参考，必读 2 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 3 Eventloop不可怕，可怕的是遇上Promise 阅读原因: 第1~3部分 参考文档 2 浏览器 进程与线程 Q1: 什么是进程和线程 A: 进程: cpu资源分配的 最小单位 + 进程之间相互独立 + 一个进程由一个/多个 线程组成 线程: cpu调度的最小单位 + 多个线程 在同一进程中 共享数据, 从而协作完成任务 Q2: 浏览器内的进程 有哪些 A: S1 浏览器是多进程的, 简单理解: 每打开一个Tab页，就相当于创建了一个独立的浏览器进程; S2 浏览器的进程组成: Browser主进程： 只有一个 + 负责各个页面的资源 管理调度 第三方插件进程：插件支持 GPU进程：最多一个 + 用于3D绘制等 浏览器渲染Renderer进程/浏览器内核: 内部多线程 + 负责 页面渲染 / 脚本执行 / 事件处理 Q3: 浏览器渲染进程内 有哪些线程 A: S1 GUI渲染线程: RenderObject树的 创建与绘制 + 与JS引擎线程 互斥 S2 JS引擎线程: 执行JS代码 S3 事件触发线程: 处理点击等事件 S4 定时触发器线程: 处理延时操作 S5 异步http请求线程: 处理AJAX请求 3 JS的运行机制—— Event Loop Q1: JS引擎是单线程的，那么它是如何执行JS代码的 A: S1 JS是单线程的，因此为了避免 异步任务堵塞 =&gt; JS把任务分为 异步任务 和 同步任务; S2 同步任务保存在 JS引擎线程管理的 执行栈A中， 依次执行; S3 异步任务保存在 事件触发线程中的 一个事件队列B，在JS执行栈空闲时 依次执行; S4 setTimeout/setInterval由 定时器线程单独管理，在传入时间后 把回调加入到 事件队列中; S5 ES6引入了promise, JS 将任务进一步细分为 宏任务 与 微任务; JS的执行流程为: script主代码 -&gt; 微任务加入到微任务队列,宏任务加入到宏任务队列 -&gt; 依次执行完 微任务队列内所有任务 -&gt; 页面重新渲染 -&gt; 宏任务2… 4 NodeJS 的Event Loop 1 Q: NodeJS 的Event Loop 流程是什么 A: S1 Node的 Event loop 共分为6个阶段: timers 阶段：执行 setTimeout/setInterval 回调 I/O callbacks 阶段 idle, prepare 阶段：仅node内部使用 poll 阶段：获取新的I/O事件 check 阶段：执行 setImmediate 回调 close callbacks 阶段 S2 node中的事件循环的执行顺序大致是： 外部输入数据–&gt; 轮询阶段(poll)–&gt; 检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer) –&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）… 2 Q: Node与浏览器的 Event Loop差异 是什么 A: S1 浏览器环境下，微任务的任务队列是每个宏任务 执行完之后执行; S2 在Node.js中，微任务会在事件循环的各个阶段之间执行 12345678910111213141516171819setTimeout(()=&gt;&#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(()=&gt;&#123; console.log('timer2') Promise.resolve().then(function() &#123; console.log('promise2') &#125;)&#125;, 0)// 浏览器端: timer1=&gt; promise1=&gt; timer2=&gt; promise2// Node.js &gt;=11: 同上// Node.js &lt;=10: timer1=&gt; promise1=&gt; timer2=&gt; promise2 或者 timer1=&gt; timer2=&gt; promise1=&gt; promise2]]></content>
      <categories>
        <category>Event Loop</category>
      </categories>
      <tags>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之async详解]]></title>
    <url>%2F2020%2F02%2F17%2FES6%E4%B9%8Basync%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言本文介绍了 async的函数特性 和 实现原理。 目录: 1 预读文档 2 async 使用特性 3 async 实现原理 1 预读文档 1 async 函数 2 来尝尝 Async函数这块语法糖 阅读原因: 直接参考文档 3 JS 异步编程六种方案 阅读原因: 对JS异步编程方法做了一个小结 2 async 使用特性 1 Q: 什么是async函数, 有什么作用 A: S1 async函数返回一个 Promise对象: 内部return的值，是then回调函数的参数 + 内部报错，返回的Promise会是 reject状态 S2 async函数内部的 所有异步操作都执行完，才会执行 then方法回调函数 S3 await后面是一个 经过Promise.resolve()方法包装后的 Promise对象 S4 任何一个 await语句后面的 Promise对象报错/ 变为reject状态, 整个async函数都会中断执行 =&gt; try…catch S5 await可以通过Promise.all 并发执行多个异步操作 3 async 实现原理 1 Q: async函数 实现原理是什么 A: 1234567891011121314151617181920212223242526272829function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; //S1 返回的是 Promsie对象 const gen = genF() //S2 执行生成器函数, 返回一个迭代器对象 &#123; next() &#123;...&#125; &#125; step(function() &#123; return gen.next(undefined) &#125;) function step(nextF) &#123; let next try &#123; next = nextF() //S3 执行g.next()方法, 返回的是一个对象 &#123;value: xxx, done: xxx &#125; &#125; catch(e) &#123; return reject(e) // S5 一旦报错, 就会立刻停止执行, 不再进行递归 &#125; if(next.done) &#123; return resolve(next.value) // S6 next.done为真时, next.value值是 生成器内部的return返回值 &#125; Promise.resolve(next.value).then(function(v) &#123; //S4 v是 next.value的值 step(function() &#123; return gen.next(v) &#125;) &#125;, function(e) &#123; step(function() &#123; return gen.throw(e) &#125;) &#125;) &#125; &#125;)&#125;]]></content>
      <categories>
        <category>async</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之 Generator详解]]></title>
    <url>%2F2020%2F02%2F16%2FES6%E4%B9%8BGenerator%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍了ES6中 Generator生成器 相关知识点。 目录: 1 预读文档 2 生成器 使用特性 3 生成器 自动执行 1 预读文档 1 Generator 函数的语法 2 ES6 系列之 Generator 的自动执行 阅读原因: 直接参考文档 2 生成器 使用特性 1 Q: 什么是生成器, 有什么作用 A: S1 Generator 是一个可以 返回迭代器的 特殊函数，它可以用来 控制异步流程; S2 通过 yield关键字+next()方法 来控制 生成器的状态切换; 2 Q: generator使用特性 有哪些 A: S1 返回的是 一个迭代器对象g: { next() {value: xxx, done: xxx } } ==&gt; for..of/扩展运算符 S2 g.next(p1)每次都会执行内代码 直到yield语句处 + p1参数值就是yield语句返回值 S3 g.throw(xx)的报错 可以被内外 try…catch语句捕获到 S4 g.return(xx) 会让 迭代器终止 S5 yield* YYY 相当于 for..of遍历执行YYY里的 [Symbol.Iterator]接口 3生成器 自动执行 1 Q: 如何让 生成器可以自动执行 异步流程 A: S1 方法一: 基于Promise的 Generator自动执行器: 1234567891011121314151617function run(generator) &#123; let gen = generator() //S1 启动迭代器 function next(data) &#123; let ret = gen.next(data) //S2 返回的是迭代器 &#123;value: Promsie对象, done: xxx&#125; if (ret.done) return; ret.value.then(function(data) &#123; // S3 data是上一次yield的 异步操作的 返回值 next(data) // 把值传入生成器内部，再次调用 gen.next(), 执行到下一次的 yield语句暂停处 &#125;) &#125; next()&#125; S2 方法二: 基于Thunk函数的 Generator自动执行器 123456789101112131415function run(generator) &#123; let gen = generator() //S1 启动迭代器 function next(data) &#123; let ret = gen.next(data) //S2 返回的是迭代器 &#123;value: Thunk函数, done: xxx&#125; if (ret.done) return; ret.value(next) // S3 next接收的data参数, 就是上一次的 异步执行的结果 &#125; next()&#125; S3 方法三: Co通用版本的 Generator自动执行器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function run(gen) &#123; let gen = gen() // S1 启动生成器, 返回一个迭代器对象 &#123;next() &#123;...&#125; &#125; return new Promise(function(resolve, reject) &#123; // S1 返回一个Promsie: 可以使后续获取到 gen的结果值 function next(data) &#123; try &#123; // S2 错误捕获, 防止yield处 的异步操作 执行错误 let ret = gen.next(data) // S3 ret是 当前状态: &#123;value: Promise/Thunk函数, done: xxx&#125; &#125; catch (e) &#123; return reject(e) &#125; if (ret.done) return resolve(ret.value) let value = toPromise(ret.value) //S4 把ret.value 必然转化为一个 Promise对象 value.then( function(data) &#123; next(data) &#125;, //S5 递归调用 gen.next() function(e) &#123;reject(e)&#125; ) &#125; next() &#125;)&#125;function isPromise(obj) &#123; return 'function' == typeof obj.then;&#125;function toPromise(obj) &#123; if (isPromise(obj)) return obj; if ('function' == typeof obj) return thunkToPromise(obj); return obj;&#125;function thunkToPromise(fn) &#123; return new Promise(function(resolve, reject) &#123; fn(function(err, res) &#123; if (err) return reject(err); resolve(res); &#125;) &#125;)&#125;]]></content>
      <categories>
        <category>ES6 Generator</category>
      </categories>
      <tags>
        <tag>ES6 Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之 迭代器详解]]></title>
    <url>%2F2020%2F02%2F12%2FES6%E4%B9%8B%20Iterator%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍了ES6中 Iterator迭代器 相关知识点。 目录: 1 预读文档 2 迭代器 3 for…of实现 1 预读文档 1 深入理解 Es6 Iterator 2 Iterator 和 for…of 循环 阅读原因: 第2部分 直接参考文档 3 ES6 系列之迭代器与 for of 阅读原因: 第3部分 直接参考文档 2 迭代器 1 Q: 什么是迭代器(Iterator), 有什么作用 A: A1 迭代器: 具有next()方法的对象 + next()返回一个 具有value和done属性的 对象 A2 迭代器的作用是: 1. 为不同数据结构 提供统一的 数据访问方式; 2. for循环的语法过于复杂 用代码表示迭代器为: 123456789101112131415161718192021function createIterator(items) &#123; let i = 0 return &#123; next() &#123; let done = (i &gt;= items.length) let value = (done ? undefined : items[i++]) return &#123; value, done &#125; &#125; &#125;&#125;let iterator = createIterator([1, 2, 3])console.log(iterator.next()) // "&#123; value: 1, done: false &#125;"console.log(iterator.next()) // "&#123; value: 2, done: false &#125;"console.log(iterator.next()) // "&#123; value: 3, done: false &#125;"console.log(iterator.next()) // "&#123; value: undefined, done: true &#125;"// 之后的所有调用console.log(iterator.next()) // "&#123; value: undefined, done: true &#125;" 2 Q: 什么是可迭代对象(Iterable), 它有什么特点 A: S1 在JS中, 只要一个对象A部署了[symbol.itetaor]方法 + 该方法返回的是Iterator, 那么对象A就是一个 可迭代对象 S2 可迭代对象的特点是: 可以通过for...of语法 访问其对象的内部数据 示例代码为: 1234567891011121314151617181920212223242526class RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; // new调用时,原型链上this指向实例对象 + 具有next()方法 next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; return &#123;done: true, value: undefined&#125;; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value); // 0, 1, 2&#125; 3 Q: 有哪些语法操作会默认调用 迭代器next()方法 A: 解构赋值 / 扩展运算符 / for…of / Array.from() / yield* 等 4 Q: 迭代器对象除了next()方法，还能有哪些方法 A: 还可以有 return()方法 + throw方法 retrun()方法在 遍历迭代器过程中 中止(break) / 报错(throw Error)时, 就会调用return方法 + return方法要返回一个对象 123456789101112131415function readFile(file) &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123;done: false&#125; &#125; // 迭代器对象的return方法 return() &#123; return &#123;done: true&#125; &#125; &#125; &#125;&#125; 3 for…of实现 1 Q: 模拟实现for…of的过程 A: S1 可迭代对象判断 + 回调函数判断 S2 自动调用 对象的迭代器方法 + 依次执行 next方法 123456789101112131415161718function forOf(obj, cb) &#123; let _iterator, _step if (typeof obj[Symbol.iterator] !== 'function') &#123; throw new TypeError(obj + 'is not iterable') &#125; if (typeof cb !== 'function') &#123; throw new TypeError('cb must be callable') &#125; _iterator = obj[Symbol.iterator]() _step = _iterator.next() while (!_step.done) &#123; cb(_step.value) _step = _iterator.next() &#125;&#125;]]></content>
      <categories>
        <category>ES6 Iterator</category>
      </categories>
      <tags>
        <tag>ES6 Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络之HTTPS详解]]></title>
    <url>%2F2020%2F02%2F12%2F%E7%BD%91%E7%BB%9C%E4%B9%8BHTTPS%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍了HTTPS 相关知识点。 目录 1 预读文档 2 HTTPS的作用 3 HTTPS的 建立过程 一 预读文档 1 HTTPS原理 阅读原因: 入门讲解视频 1 深入理解HTTPS工作原理 阅读原因: 第2部分 直接参考文档 + HTTPS的原理介绍 2 看图学HTTPS 阅读原因: 第3部分 直接参考文档 + HTTPS的原理介绍 二 HTTPS的作用 1 Q: 为什么要引入HTTPS A: 由于HTTP有以下 安全问题，所以引入HTTPS解决这些问题: S1 HTTP采用明文通信, 数据容易被窃听; S2 HTTP不会检测数据传输的完整性, 所以数据容易被 篡改; S3 HTTP没有任何身份验证, 所以有可能被 中间人身份伪造; HTTPS在 TCP 和 HTTP层之间, 新增了 SSL/TLS安全层, 用来保证HTTP通话过程中的 信息安全和身份认证。 2 Q: HTTPS 和 HTTP的区别 A: S1 默认连接的 端口不同: HTTP的默认连接端口是80, HTTPS的默认连接端口是443; S2 需要的证书不同: HTTPS需要用到SSL证书，而HTTP不用; S3 安全性不同: HTTP采用明文传输, 而HTTPS 采用SSL加密传输; S4 HTTPS 对搜索引擎更友好 三 HTTPS的 建立过程 1 Q: HTTPS的原理是什么 A: 实现原理是: 对称加密(如AES) + 非对称加密(如RSA) + 散列算法(如SHA) + CA第3方认证 具体含义, 可参考 预读文档1 和 预读文档2 2 Q: HTTPS的建立过程是什么 A: S1 客户端A 请求建立SSL连接，并向服务端B 发送一个随机数1 和 客户端支持的 非对称加密方法; S2 服务端B 选择客户端支持的一种加密算法 =&gt; 生成另一个随机数2 + 将 数字证书(其中包含 服务器公钥P1) 发给客户端A; S3 A进行证书验证，验证通过=&gt; 生成一个新的随机数3 + 通过P1公钥及加密方法进行加密，发送给B; S4 B 用 私钥 P’1 进行解密, 获取到随机数3 =&gt; 利用随机数1,2,3生成 对称加密key- session key; 以上也是 SSL层的 4次握手过程 再补充说明一下 数字证书验证的具体细节(数字证书用来解决 身份验证和 数据完整性验证) S1 数字证书包括: 网站明文信息 + 服务器公钥P1 + 数字签名(明文信息+散列算法(如Hash)——&gt; 消息摘要D + CA的私钥P2&#39;——&gt; 数字签名) S2.1 客户端获取到数字证书后, 会使用内置在 操作系统中的 CA公钥P2 解密数字签名, 从而获取到 消息摘要D; S2.2 客户端利用 网站明文信息 + 散列算法——&gt; 生成消息摘要D2; S2.3 比较 D 和 D2的值, 如果一致则 验证通过; S3 数字签名的作用，验证了传输来的 服务器端公钥P1的 真实性, 数字签名验证机制 解决了 中间人身份伪造的问题]]></content>
      <categories>
        <category>HTTPS</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络之 跨域方法]]></title>
    <url>%2F2020%2F02%2F06%2F%E7%BD%91%E7%BB%9C%E4%B9%8B%20%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言本文实现了常见的 跨域方法。 目录: 1 预读文档 2 为什么要进行跨域 3 跨域常用方法 一 预读文档 1 可能是最好的跨域解决方案 阅读原因: 同源策略直接参考文档 2 九种跨域方式实现原理 阅读原因: JSONP/ CORS部分/Nginx反向代理/postMessage/websocket 直接参考文档 3 跨域要不要了解下 CORS 基础篇 阅读原因: CORS部分 直接参考文档2 4 正确面对跨域，别慌 阅读原因: Node中间件代理部分 直接参考文档 5 我知道的跨域与安全 阅读原因: 与安全相关部分, 待读… 二 为什么要进行跨域 1 Q: 为什么要进行跨域 A: S1 由于浏览器的同源策略 S2 所谓同源策略，是指 浏览器规定, 请求源A和响应源B之间的 协议、域名、端口号必须完全一致，才可以进行正常通信; 如果请求A和响应B 之间 不同源,浏览器就会有以下 安全限制: A1 A无法读取B的 存储性内容：如 cookie/localStorage/IndexDB A2 A无法获取到B 的DOM节点 A3 B返回的AJAX请求响应会被 A的浏览器拦截 三 跨域常用方法 1 Q: 如何实现跨域 方法1: JSONP S1 原理是: script/img等 静态资源文件请求没有 同源策略限制 + 请求返回的响应是 合法的JS语句 + script标签内的JS语句会自动执行 S2 JSONP的优点: 简单, 兼容性好 S3 JSONP的缺点: 只支持get请求 + 需要前后端配合实现 + 存在安全性问题 前端部分的 具体实现 123456789101112131415161718192021222324252627282930// 使用jsonp(&#123; url: 'http://localhost:3000/say', params: &#123; wd: 'Iloveyou' &#125;, callback: 'show'&#125;).then(data =&gt; &#123; console.log(data)&#125;)function jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; params = &#123;...params, callback&#125; let arr = [] for(let key in params) &#123; arr.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) // S2 [wd=b, callback=show] &#125; let script = document.createElement('script') //S1 创建一个&lt;script&gt;标签，src为跨域地址 script.src = `$&#123;url&#125;?$&#123;arr.join('&amp;')&#125;` // S3 ?wd=b&amp;callback=show document.body.appendChild(script) window[callback] = function(data) &#123; //S4 A执行 之前声明的回调函数，对返回的数据进行操作 resolve(data) document.body.removeChild(script) &#125; &#125;)&#125; 方法2: CORS (跨域资源共享) S1 CORS主要是由 服务器端设置一系列响应头，来解决跨域限制 S2 需要设置的响应头,主要有以下几种: Access-Control-Allow-Origin: 设置 允许的 跨域源 Access-Control-Allow-Headers: 设置 允许的 跨域请求头 Access-Control-Allow-Methods: 设置 允许的 跨域请求方法 Access-Control-Allow-Credentials: 设置 是否允许携带cookie, 如果要携带cookie, 也需要请求端设置xhr.withCredentials = true Access-Control-Max-Age: 设置 预检请求的存活时间 S3 预检请求和 请求分类有关。 请求分为 简单请求和复杂请求; 简单请求: 请求方法为get/post/head + contnet-type值为以下3种之一: application/x-www-urlencoded &amp; multipart/form-data &amp; text/plain 在发送复杂请求前, 浏览器会先发送一个方法为OPTION的预检请求, 以向服务器确定相关跨域信息。 方法3: Node中间件代理(正向代理) S1 原理是: A向 代理服务器B发送请求 + B向目标服务器C转发请求 + 服务器B和C之间无 同源限制 方法4: nginx反向代理 S1 原理是: A向 代理服务器B发送请求 + B向任意某个服务器C转发请求(负载均衡) 123456789101112131415161718192021222324server &#123; # 监听80端口号 listen 80; # 监听访问的域名 server_name www.domain1.com; # 根据访问路径配置 location / &#123; # 反向代理 proxy_pass http://www.domain2.com:8080; # 修改cookie里域名 proxy_cookie_domain www.domain2.com www.domain1.com; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 # 当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Origin http://www.domain1.com; add_header Access-Control-Allow-Credentials true; &#125;&#125; 方法5: postMessage 12345678910111213141516//发送数据iframe.contentWindow.postMessage('A to B', 'http://b.com:4000')//接受返回数据window.onmessage = function(e) &#123; console.log(e.data) // B back to A&#125;// bwindow.onmessage = function(e) &#123; console.log(e.data) // A to B e.source.postMessage('B back to A', e.origin)&#125; 方法6: websocket 1234567891011121314151617181920212223242526272829303132&lt;script&gt; // socket.html let socket = new WebSocket('ws://b.com:4000')socket.onopen = function () &#123; socket.send('A to B'); //向服务器发送数据&#125;socket.onmessage = function (e) &#123; console.log(e.data); //接收服务器返回的数据&#125;// server.jslet express = require('express');let app = express();let WebSocket = require('ws'); //安装wslet wss = new WebSocket.Server( &#123;port:3000&#125; );wss.on('connection', function(ws) &#123; // B 向 A 返回信息 ws.on('message', function (data) &#123; console.log(data) ws.send('B back to A') &#125;)&#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>跨域方法</category>
      </categories>
      <tags>
        <tag>跨域方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之 Promise详解]]></title>
    <url>%2F2020%2F02%2F04%2FES6%E4%B9%8B%20Promise%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言本文实现了 Promise的所有常见方法。 目录: 1 预读文档 2 promise实现 3 promise其他方法 实现 1 预读文档 1 Promise源码讲解 2 Promise的源码实现 阅读原因: 第2、3部分 直接参考视频 + 文档 2 promise实现 1 Q: 如何实现一个 promise A: S1 then的多个回调: 发布订阅 S2 then的链式调用: 返回新的promsie对象 + 获取回调函数值 S3 新Promise对象的返回值: 由then内的回调函数值 决定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141const PENDING = 'pending'const RESOLVED = 'resolved'const REJECTED = 'rejected'function Promise(executor) &#123; let self = this self.status = PENDING // 初始化状态 self.value = undefined self.reason = undefined self.onResolvedCallbacks = [] self.onRejectedCallbacks = [] function resolve(value) &#123; // 防止调用多次不同状态 if (self.status === PENDING) &#123; self.status = RESOLVED self.value = value self.onResolvedCallbacks.forEach(fn =&gt; fn()) &#125; &#125; function reject(reason) &#123; if (self.status === PENDING) &#123; self.status = REJECTED self.reason = reason self.onRejectedCallbacks.forEach(fn =&gt; fn()) &#125; &#125; try &#123; executor(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this let promise2 // then的参数 非函数时, 穿透上一个Promise的返回值 onFulfilled = (typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value) onRejected = (typeof onrejected === 'function' ? onRejected : err =&gt; &#123; throw err &#125;) // then返回的是一个新的Promise对象,且对象值 由onFulfilled/onRejected的返回值决定 promise2 = new Promise((resolve, reject) =&gt; &#123; if (self.status === RESOLVED) &#123; // 异步执行回调函数, 以获取到promise2的值 setTimeout(() =&gt; &#123; try &#123; // 防止执行回调时内部有报错 let x = onFulfilled(self.value) resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125; else if (self.status === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.reason) resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125; else if (self.status === PENDING) &#123; self.onResolvedCallbacks.push(() =&gt; &#123; // 存入的函数同上是 异步的 setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;, 0) &#125;) self.onRejectedCallbacks.push( () =&gt; &#123; setTimeout( ()=&gt; &#123; try &#123; let x = onRejected(self.reason) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125; , 0) &#125;) &#125; &#125;) return promise2&#125;function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; reject(new TypeError('循环引用了')) &#125; if(x &amp;&amp; typeof x === 'object' || typeof x === 'function') &#123; let used // 兼容所有Promise实现, 确保只能改变一次状态值 try &#123; // 防止获取then时通过Object.defineProperty报错 let then = x.then if (typeof then === 'function') &#123; // 则认为x是 promsie对象 then.call(x, // 通过then来获取并传出 promise对象的值 (y) =&gt; &#123; if (used) return; used = true resolvePromise(promise2, y, resolve, reject) //防止y又是一个promise对象 &#125;, (r) =&gt; &#123; if (used) return; used = true reject(r) &#125; ) &#125; else &#123; // then非函数,说明是普通对象 if (used) return; used = true resolve(x) &#125; &#125; catch(e) &#123; if (used) return; used = true reject(e) &#125; &#125; else &#123; // then的返回值是 基本数据类型，返回成功状态的该值 resolve(x) &#125;&#125; 3 promise其他方法 实现 1 Q: 如何实现 promise其他方法 A: S1 promise.resolve方法: 返回 一个给定值解析后的 promise对象 S2 promise.reject方法: 返回一个失败状态的 promise对象 S3 promise.all方法: 只有全部成功时，才返回一个成功的promise对象，值是有序数组 S4 promise.race方法: 获取最先完成的 promise返回值 S5 promise.prototype.catch方法: then的语法糖 S6 promise.prototype.finally方法: 必然执行的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103Promise.resolve = function(params) &#123; if (params instanceof Promise) &#123; // 如果传入的是promise对象,直接返回它即可 return params &#125; return new Promise( (resolve, reject) =&gt; &#123; if (params &amp;&amp; params.then &amp;&amp; typeof params.then === 'function') &#123; // thenable对象时，直接调用其then函数即可 params.then(resolve, reject) &#125; else &#123; // 普通值，则直接返回 以该值为成功状态的promise对象 resolve(parmas) &#125; &#125;)&#125;// promise.reject方法Promsie.reject = function(reason)&#123; return new Promise( (resolve, reject) =&gt; &#123; reject(reason) &#125;)&#125;// promise.all方法Promise.all = function(promises) &#123; return new Promise( (resolve, reject) =&gt; &#123; let result = [] // 返回结果值 let index = 0 // 对异步操作结果获取的计数器 if (promises.length === 0) &#123; // 空数组传入，则同步 返回空的数组 resolve(result) &#125; for (let i=0; i&lt;promises.length; i++) &#123; // 因为promises可能是同步数据/promsie对象, 所以需要用resolve变成对应状态的 promise Promise.resolve(promises[i]).then( data=&gt; &#123; // 因为需要判断多个异步操作是否都获取到了值，所以封装成一个函数处理 processData(i, data) // 如果有一个失败了，则整个 promsie.all状态也是 失败的 &#125;,reject) &#125; function processData(i, data) &#123; result[i] = data // 用index而非 result.length来判断的原因是, 如果result[9] = 100, 则其长度为10 // 但实际异步结果可能并未获取到, 所以利用index计数器来判断 异步操作是否完成 if (++index === promises.length) &#123; resolve(result) &#125; &#125; &#125;)&#125;//Promise.race方法Promise.race = function(promises) &#123; if (promises.length === 0) &#123; return; // 如果传入数组为空，则一直是pending状态 &#125; return new Promise( (resolve, reject) =&gt; &#123; for (let i=0; i&lt;promises.length; i++) &#123; // 遍历并执行 promises数组内容即可, 在执行完第一个返回内容后，终止程序执行 Promise.reslove(promises[i]).then(data =&gt; &#123; resolve(data) return; &#125;, err =&gt; &#123; reject(err) return; &#125;) &#125; &#125;)&#125;// promise.prototype.catch方法Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected)&#125;// promise.prototype.finally方法Promise.prototype.finally = function(cb) &#123; // 用then来接收 上一个Promise的状态和 返回值 return this.then((value)=&gt; &#123; // 用resolve来保证回调函数是异步时，也还是在执行完成后才返回 上一个Promise的值 return Promise.resolve( cb() ).then( () =&gt; &#123; // finally的核心点: 执行回调 + 传递上一个Promise的值 return value &#125;) &#125;, (err)=&gt;&#123; return Promise.resolve( cb() ).then( () =&gt; &#123; throw err &#125;) &#125;)&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2019%2F04%2F21%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[这周用hexo和github Pages搭建了自己的静态博客，这是过程中的小结记录。 因为主要是用来给自己备忘的，所以只是直接记录了相关的参考文档。 一 博客搭建过程1 Q: 如何搭建博客 S1 实现基本博客功能，参考这个文档即可: hexo教程：github page+独立域名搭建(1) S2 配置博客主题，依次参考以下文档: 01 hexo的next主题个性化配置教程 02 next官方文档 03 底部文字居中 04 代码块复制功能 S3 利用git分支进行多终端工作，具体可见: hexo教程:基本配置+更换主题+多终端工作+coding page部署分流(2) S4 发布步骤,代码见下: 1234567hexo cleanhexo s --debughexo dhexo g]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
