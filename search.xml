<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6之 迭代器详解]]></title>
    <url>%2F2020%2F02%2F12%2FES6%E4%B9%8B%20Iterator%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍了ES6中 Iterator迭代器 相关知识点。 目录: 1 预读文档 2 迭代器 3 for…of实现 1 预读文档 1 深入理解 Es6 Iterator 2 Iterator 和 for…of 循环 阅读原因: 第2部分 直接参考文档 3 ES6 系列之迭代器与 for of 阅读原因: 第3部分 直接参考文档 2 迭代器 1 Q: 什么是迭代器(Iterator), 有什么作用 A: A1 迭代器: 具有next()方法的对象 + next()返回一个 具有value和done属性的 对象 A2 迭代器的作用是: 1. 为不同数据结构 提供统一的 数据访问方式; 2. for循环的语法过于复杂 用代码表示迭代器为: 123456789101112131415161718192021function createIterator(items) &#123; let i = 0 return &#123; next() &#123; let done = (i &gt;= items.length) let value = (done ? undefined : items[i++]) return &#123; value, done &#125; &#125; &#125;&#125;let iterator = createIterator([1, 2, 3])console.log(iterator.next()) // "&#123; value: 1, done: false &#125;"console.log(iterator.next()) // "&#123; value: 2, done: false &#125;"console.log(iterator.next()) // "&#123; value: 3, done: false &#125;"console.log(iterator.next()) // "&#123; value: undefined, done: true &#125;"// 之后的所有调用console.log(iterator.next()) // "&#123; value: undefined, done: true &#125;" 2 Q: 什么是可迭代对象(Iterable), 它有什么特点 A: S1 在JS中, 只要一个对象A部署了[symbol.itetaor]方法 + 该方法返回的是Iterator, 那么对象A就是一个 可迭代对象 S2 可迭代对象的特点是: 可以通过for...of语法 访问其对象的内部数据 示例代码为: 1234567891011121314151617181920212223242526class RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; // new调用时,原型链上this指向实例对象 + 具有next()方法 next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; return &#123;done: true, value: undefined&#125;; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value); // 0, 1, 2&#125; 3 Q: 有哪些语法操作会默认调用 迭代器next()方法 A: 解构赋值 / 扩展运算符 / for…of / Array.from() / yield* 等 4 Q: 迭代器对象除了next()方法，还能有哪些方法 A: 还可以有 return()方法 + throw方法 retrun()方法在 遍历迭代器过程中 中止(break) / 报错(throw Error)时, 就会调用return方法 + return方法要返回一个对象 123456789101112131415function readFile(file) &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123;done: false&#125; &#125; // 迭代器对象的return方法 return() &#123; return &#123;done: true&#125; &#125; &#125; &#125;&#125; 3 for…of实现 1 Q: 模拟实现for…of的过程 A: S1 可迭代对象判断 + 回调函数判断 S2 自动调用 对象的迭代器方法 + 依次执行 next方法 123456789101112131415161718function forOf(obj, cb) &#123; let _iterator, _step if (typeof obj[Symbol.iterator] !== 'function') &#123; throw new TypeError(obj + 'is not iterable') &#125; if (typeof cb !== 'function') &#123; throw new TypeError('cb must be callable') &#125; _iterator = obj[Symbol.iterator]() _step = _iterator.next() while (!_step.done) &#123; cb(_step.value) _step = _iterator.next() &#125;&#125;]]></content>
      <categories>
        <category>ES6 Iterator</category>
      </categories>
      <tags>
        <tag>ES6 Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络之HTTPS详解]]></title>
    <url>%2F2020%2F02%2F12%2F%E7%BD%91%E7%BB%9C%E4%B9%8BHTTPS%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍了HTTPS 相关知识点。 目录 1 预读文档 2 HTTPS的作用 3 HTTPS的 建立过程 一 预读文档 1 HTTPS原理 阅读原因: 入门讲解视频 1 深入理解HTTPS工作原理 阅读原因: 第2部分 直接参考文档 + HTTPS的原理介绍 2 看图学HTTPS 阅读原因: 第3部分 直接参考文档 + HTTPS的原理介绍 二 HTTPS的作用 1 Q: 为什么要引入HTTPS A: 由于HTTP有以下 安全问题，所以引入HTTPS解决这些问题: S1 HTTP采用明文通信, 数据容易被窃听; S2 HTTP不会检测数据传输的完整性, 所以数据容易被 篡改; S3 HTTP没有任何身份验证, 所以有可能被 中间人身份伪造; HTTPS在 TCP 和 HTTP层之间, 新增了 SSL/TLS安全层, 用来保证HTTP通话过程中的 信息安全和身份认证。 2 Q: HTTPS 和 HTTP的区别 A: S1 默认连接的 端口不同: HTTP的默认连接端口是80, HTTPS的默认连接端口是443; S2 需要的证书不同: HTTPS需要用到SSL证书，而HTTP不用; S3 安全性不同: HTTP采用明文传输, 而HTTPS 采用SSL加密传输; S4 HTTPS 对搜索引擎更友好 三 HTTPS的 建立过程 1 Q: HTTPS的原理是什么 A: 实现原理是: 对称加密(如AES) + 非对称加密(如RSA) + 散列算法(如SHA) + CA第3方认证 具体含义, 可参考 预读文档1 和 预读文档2 2 Q: HTTPS的建立过程是什么 A: S1 客户端A 请求建立SSL连接，并向服务端B 发送一个随机数1 和 客户端支持的 非对称加密方法; S2 服务端B 选择客户端支持的一种加密算法 =&gt; 生成另一个随机数2 + 将 数字证书(其中包含 服务器公钥P1) 发给客户端A; S3 A进行证书验证，验证通过=&gt; 生成一个新的随机数3 + 通过P1公钥及加密方法进行加密，发送给B; S4 B 用 私钥 P’1 进行解密, 获取到随机数3 =&gt; 利用随机数1,2,3生成 对称加密key- session key; 以上也是 SSL层的 4次握手过程 再补充说明一下 数字证书验证的具体细节(数字证书用来解决 身份验证和 数据完整性验证) S1 数字证书包括: 网站明文信息 + 服务器公钥P1 + 数字签名(明文信息+散列算法(如Hash)——&gt; 消息摘要D + CA的私钥P2&#39;——&gt; 数字签名) S2.1 客户端获取到数字证书后, 会使用内置在 操作系统中的 CA公钥P2 解密数字签名, 从而获取到 消息摘要D; S2.2 客户端利用 网站明文信息 + 散列算法——&gt; 生成消息摘要D2; S2.3 比较 D 和 D2的值, 如果一致则 验证通过; S3 数字签名的作用，验证了传输来的 服务器端公钥P1的 真实性, 数字签名验证机制 解决了 中间人身份伪造的问题]]></content>
      <categories>
        <category>HTTPS</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络之 跨域方法]]></title>
    <url>%2F2020%2F02%2F06%2F%E7%BD%91%E7%BB%9C%E4%B9%8B%20%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言本文实现了常见的 跨域方法。 目录: 1 预读文档 2 为什么要进行跨域 3 跨域常用方法 一 预读文档 1 可能是最好的跨域解决方案 阅读原因: 同源策略直接参考文档 2 九种跨域方式实现原理 阅读原因: JSONP/ CORS部分/Nginx反向代理/postMessage/websocket 直接参考文档 3 跨域要不要了解下 CORS 基础篇 阅读原因: CORS部分 直接参考文档2 4 正确面对跨域，别慌 阅读原因: Node中间件代理部分 直接参考文档 5 我知道的跨域与安全 阅读原因: 与安全相关部分, 待读… 二 为什么要进行跨域 1 Q: 为什么要进行跨域 A: S1 由于浏览器的同源策略 S2 所谓同源策略，是指 浏览器规定, 请求源A和响应源B之间的 协议、域名、端口号必须完全一致，才可以进行正常通信; 如果请求A和响应B 之间 不同源,浏览器就会有以下 安全限制: A1 A无法读取B的 存储性内容：如 cookie/localStorage/IndexDB A2 A无法获取到B 的DOM节点 A3 B返回的AJAX请求响应会被 A的浏览器拦截 三 跨域常用方法 1 Q: 如何实现跨域 方法1: JSONP S1 原理是: script/img等 静态资源文件请求没有 同源策略限制 + 请求返回的响应是 合法的JS语句 + script标签内的JS语句会自动执行 S2 JSONP的优点: 简单, 兼容性好 S3 JSONP的缺点: 只支持get请求 + 需要前后端配合实现 + 存在安全性问题 前端部分的 具体实现 123456789101112131415161718192021222324252627282930// 使用jsonp(&#123; url: 'http://localhost:3000/say', params: &#123; wd: 'Iloveyou' &#125;, callback: 'show'&#125;).then(data =&gt; &#123; console.log(data)&#125;)function jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; params = &#123;...params, callback&#125; let arr = [] for(let key in params) &#123; arr.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) // S2 [wd=b, callback=show] &#125; let script = document.createElement('script') //S1 创建一个&lt;script&gt;标签，src为跨域地址 script.src = `$&#123;url&#125;?$&#123;arr.join('&amp;')&#125;` // S3 ?wd=b&amp;callback=show document.body.appendChild(script) window[callback] = function(data) &#123; //S4 A执行 之前声明的回调函数，对返回的数据进行操作 resolve(data) document.body.removeChild(script) &#125; &#125;)&#125; 方法2: CORS (跨域资源共享) S1 CORS主要是由 服务器端设置一系列响应头，来解决跨域限制 S2 需要设置的响应头,主要有以下几种: Access-Control-Allow-Origin: 设置 允许的 跨域源 Access-Control-Allow-Headers: 设置 允许的 跨域请求头 Access-Control-Allow-Methods: 设置 允许的 跨域请求方法 Access-Control-Allow-Credentials: 设置 是否允许携带cookie, 如果要携带cookie, 也需要请求端设置xhr.withCredentials = true Access-Control-Max-Age: 设置 预检请求的存活时间 S3 预检请求和 请求分类有关。 请求分为 简单请求和复杂请求; 简单请求: 请求方法为get/post/head + contnet-type值为以下3种之一: application/x-www-urlencoded &amp; multipart/form-data &amp; text/plain 在发送复杂请求前, 浏览器会先发送一个方法为OPTION的预检请求, 以向服务器确定相关跨域信息。 方法3: Node中间件代理(正向代理) S1 原理是: A向 代理服务器B发送请求 + B向目标服务器C转发请求 + 服务器B和C之间无 同源限制 方法4: nginx反向代理 S1 原理是: A向 代理服务器B发送请求 + B向任意某个服务器C转发请求(负载均衡) 123456789101112131415161718192021222324server &#123; # 监听80端口号 listen 80; # 监听访问的域名 server_name www.domain1.com; # 根据访问路径配置 location / &#123; # 反向代理 proxy_pass http://www.domain2.com:8080; # 修改cookie里域名 proxy_cookie_domain www.domain2.com www.domain1.com; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 # 当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Origin http://www.domain1.com; add_header Access-Control-Allow-Credentials true; &#125;&#125; 方法5: postMessage 12345678910111213141516//发送数据iframe.contentWindow.postMessage('A to B', 'http://b.com:4000')//接受返回数据window.onmessage = function(e) &#123; console.log(e.data) // B back to A&#125;// bwindow.onmessage = function(e) &#123; console.log(e.data) // A to B e.source.postMessage('B back to A', e.origin)&#125; 方法6: websocket 1234567891011121314151617181920212223242526272829303132&lt;script&gt; // socket.html let socket = new WebSocket('ws://b.com:4000')socket.onopen = function () &#123; socket.send('A to B'); //向服务器发送数据&#125;socket.onmessage = function (e) &#123; console.log(e.data); //接收服务器返回的数据&#125;// server.jslet express = require('express');let app = express();let WebSocket = require('ws'); //安装wslet wss = new WebSocket.Server( &#123;port:3000&#125; );wss.on('connection', function(ws) &#123; // B 向 A 返回信息 ws.on('message', function (data) &#123; console.log(data) ws.send('B back to A') &#125;)&#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>跨域方法</category>
      </categories>
      <tags>
        <tag>跨域方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之 Promise详解]]></title>
    <url>%2F2020%2F02%2F04%2FES6%E4%B9%8B%20Promise%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言本文实现了 Promise的所有常见方法。 目录: 1 预读文档 2 promise实现 3 promise其他方法 实现 1 预读文档 1 Promise源码讲解 2 Promise的源码实现 阅读原因: 第2、3部分 直接参考视频 + 文档 2 promise实现 1 Q: 如何实现一个 promise A: S1 then的多个回调: 发布订阅 S2 then的链式调用: 返回新的promsie对象 + 获取回调函数值 S3 新Promise对象的返回值: 由then内的回调函数值 决定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141const PENDING = 'pending'const RESOLVED = 'resolved'const REJECTED = 'rejected'function Promise(executor) &#123; let self = this self.status = PENDING // 初始化状态 self.value = undefined self.reason = undefined self.onResolvedCallbacks = [] self.onRejectedCallbacks = [] function resolve(value) &#123; // 防止调用多次不同状态 if (self.status !== PENDING) &#123; self.status = RESOLVED self.value = value self.onResolvedCallbacks.forEach(fn =&gt; fn()) &#125; &#125; function reject(reason) &#123; if (self.status !== PENDING) &#123; self.status = REJECTED self.reason = reason self.onRejectedCallbacks.forEach(fn =&gt; fn()) &#125; &#125; try &#123; executor(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this let promise2 // then的参数 非函数时, 穿透上一个Promise的返回值 onFulfilled = (typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value) onRejected = (typeof onrejected === 'function' ? onRejected : err =&gt; &#123; throw err &#125;) // then返回的是一个新的Promise对象,且对象值 由onFulfilled/onRejected的返回值决定 promise2 = new Promise((resolve, reject) =&gt; &#123; if (self.status === RESOLVED) &#123; // 异步执行回调函数, 以获取到promise2的值 setTimeout(() =&gt; &#123; try &#123; // 防止执行回调时内部有报错 let x = onFulfilled(self.value) resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125; else if (self.status === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.reason) resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125; else if (self.status === PENDING) &#123; self.onResolvedCallbacks.push(() =&gt; &#123; // 存入的函数同上是 异步的 setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;, 0) &#125;) self.onRejectedCallbacks.push( () =&gt; &#123; setTimeout( ()=&gt; &#123; try &#123; let x = onRejected(self.reason) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125; , 0) &#125;) &#125; &#125;) return promise2&#125;function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; reject(new TypeError('循环引用了')) &#125; if(x &amp;&amp; typeof x === 'object' || typeof x === 'function') &#123; let used // 兼容所有Promise实现, 确保只能改变一次状态值 try &#123; // 防止获取then时通过Object.defineProperty报错 let then = x.then if (typeof then === 'function') &#123; // 则认为x是 promsie对象 then.call(x, // 通过then来获取并传出 promise对象的值 (y) =&gt; &#123; if (used) return; used = true resolvePromise(promise2, y, resolve, reject) //防止y又是一个promise对象 &#125;, (r) =&gt; &#123; if (used) return; used = true reject(r) &#125; ) &#125; else &#123; // then非函数,说明是普通对象 if (used) return; used = true resolve(x) &#125; &#125; catch(e) &#123; if (used) return; used = true reject(e) &#125; &#125; else &#123; // then的返回值是 基本数据类型，返回成功状态的该值 resolve(x) &#125;&#125; 3 promise其他方法 实现 1 Q: 如何实现 promise其他方法 A: S1 promise.resolve方法: 返回 一个给定值解析后的 promise对象 S2 promise.reject方法: 返回一个失败状态的 promise对象 S3 promise.all方法: 只有全部成功时，才返回一个成功的promise对象，值是有序数组 S4 promise.race方法: 获取最先完成的 promise返回值 S5 promise.prototype.catch方法: then的语法糖 S6 promise.prototype.finally方法: 必然执行的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103Promise.resolve = function(params) &#123; if (params instanceof Promise) &#123; // 如果传入的是promise对象,直接返回它即可 return params &#125; return new Promise( (resolve, reject) =&gt; &#123; if (params &amp;&amp; params.then &amp;&amp; typeof params.then === 'function') &#123; // thenable对象时，直接调用其then函数即可 params.then(resolve, reject) &#125; else &#123; // 普通值，则直接返回 以该值为成功状态的promise对象 resolve(parmas) &#125; &#125;)&#125;// promise.reject方法Promsie.reject = function(reason)&#123; return new Promise( (resolve, reject) =&gt; &#123; reject(reason) &#125;)&#125;// promise.all方法Promise.all = function(promises) &#123; return new Promise( (resolve, reject) =&gt; &#123; let result = [] // 返回结果值 let index = 0 // 对异步操作结果获取的计数器 if (promises.length === 0) &#123; // 空数组传入，则同步 返回空的数组 resolve(result) &#125; for (let i=0; i&lt;promises.length; i++) &#123; // 因为promises可能是同步数据/promsie对象, 所以需要用resolve变成对应状态的 promise Promise.resolve(promises[i]).then( data=&gt; &#123; // 因为需要判断多个异步操作是否都获取到了值，所以封装成一个函数处理 processData(i, data) // 如果有一个失败了，则整个 promsie.all状态也是 失败的 &#125;,reject) &#125; function processData(i, data) &#123; result[i] = data // 用index而非 result.length来判断的原因是, 如果result[9] = 100, 则其长度为10 // 但实际异步结果可能并未获取到, 所以利用index计数器来判断 异步操作是否完成 if (++index === promises.length) &#123; resolve(result) &#125; &#125; &#125;)&#125;//Promise.race方法Promise.race = function(promises) &#123; if (promises.length === 0) &#123; return; // 如果传入数组为空，则一直是pending状态 &#125; return new Promise( (resolve, reject) =&gt; &#123; for (let i=0; i&lt;promises.length; i++) &#123; // 遍历并执行 promises数组内容即可, 在执行完第一个返回内容后，终止程序执行 Promise.reslove(promises[i]).then(data =&gt; &#123; resolve(data) return; &#125;, err =&gt; &#123; reject(err) return; &#125;) &#125; &#125;)&#125;// promise.prototype.catch方法Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected)&#125;// promise.prototype.finally方法Promise.prototype.finally = function(cb) &#123; // 用then来接收 上一个Promise的状态和 返回值 return this.then((value)=&gt; &#123; // 用resolve来保证回调函数是异步时，也还是在执行完成后才返回 上一个Promise的值 return Promise.resolve( cb() ).then( () =&gt; &#123; // finally的核心点: 执行回调 + 传递上一个Promise的值 return value &#125;) &#125;, (err)=&gt;&#123; return Promise.resolve( cb() ).then( () =&gt; &#123; throw err &#125;) &#125;)&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2019%2F04%2F21%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[这周用hexo和github Pages搭建了自己的静态博客，这是过程中的小结记录。 因为主要是用来给自己备忘的，所以只是直接记录了相关的参考文档。 一 博客搭建过程1 Q: 如何搭建博客 S1 实现基本博客功能，参考这个文档即可: hexo教程：github page+独立域名搭建(1) S2 配置博客主题，依次参考以下文档: 01 hexo的next主题个性化配置教程 02 next官方文档 03 底部文字居中 04 代码块复制功能 S3 利用git分支进行多终端工作，具体可见: hexo教程:基本配置+更换主题+多终端工作+coding page部署分流(2) S4 发布步骤,代码见下: 1234567hexo cleanhexo s --debughexo dhexo g]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
