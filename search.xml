<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[script defer和async区别]]></title>
    <url>%2F2019%2F08%2F10%2Fscript%20defer%E5%92%8Casync%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[本文比较简单，主要是对 script async 和 script defer的区别进行了小结。 script defer和async区别目录: 1 预读文档 2 defer和async区别 1 预读文档 1 defer和async的区别 阅读原因: 最佳参考文档 2 defer 和 async 区别 1 script: 读取到script文件时: 停止HTML渲染 + 立刻下载script + 立刻执行script + 继续HTML渲染 2 script async: 在HTML渲染时并行下载JS文件 + 下载好后立刻执行JS文件 + 执行完成后继续HTML渲染 3 script defer: 在HTML渲染时并行下载JS文件 + 完成所有HTML渲染后，才会执行JS文件 4 最后，一图胜千言:]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域之 从执行上下文到闭包]]></title>
    <url>%2F2019%2F07%2F21%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B9%8B%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%B0%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[本文是对 闭包的相关知识小结。 作用域之 闭包目录: 1 预读文档 2 什么是闭包 3 闭包的实质 4 闭包的作用 5 闭包的问题 1 预读文档 1 JavaScript深入之执行上下文栈 2 JavaScript深入之变量对象 3 JavaScript深入之作用域链 4 JavaScript深入之执行上下文 5 JavaScript深入之闭包 阅读原因: 详细介绍了闭包相关的知识点 2 什么是闭包直接看实例代码: 1234567891011121314151617181920var num = 10function addOne (num) &#123; var result = num fucntion temp () &#123; ..... &#125; var add = function () &#123; return (result + 1) &#125; return add&#125;let result = addOne(4)console.log(result()) 步骤分析: S1 调用全局代码，会创建 全局的执行上下文对象，即 ctxStack = [globalCtx] S2 进入准备阶段，产生globalCtx.VO + 执行全局代码 S3 调用addone函数，创建addone执行上下文，即 ctxStack = [addoneCtx, globalCtx] S3.1 addone函数定义阶段: 会有一个[[scope]]属性，值是 所有外层函数的变量对象数组，即addone.[[scope]] = [globalCtx.VO] S3.2 addone函数准备阶段: 初始化addoneCtx.AO + 定义add函数时生成 add.[[scope]] = [addoneCtx.AO,globalCtx.VO] 12345678910111213141516// 函数准备阶段addOneCtx = &#123; AO: &#123; arguments: &#123; 0: 1, length: 1 &#125;, num: 4, // 形参变量 + 实参值 temp: reference to function, // 之后的同名变量声明 不会影响已有的函数声明 result: undefined, add: undefined // 注意区分函数声明 和 函数表达式 &#125;&#125; S3.3 addone函数执行阶段：赋值addoneContext.AO值 + 生成作用域链Scope属性，值是 当前的AO + 定义生成的[[scope]]属性 12345678910111213141516// 函数执行阶段addOneCtx = &#123; AO: &#123; arguments: &#123; 0: 1, length: 1 &#125;, num: 4, temp: reference to function, result: 4, add:: reference to FunctionExpression //注意区分函数声明 和 函数表达式 &#125;, Scope: [AO, addOneCtx.[[scope]]] //addOneCtx.[[scope]] = [globalCtx.VO]&#125; S3.4 执行完addone函数: 其执行上下文销毁出栈，即 ECStack = [globalContext] S4.1 执行add/foo函数， 生成上下文addCtx并入栈 S4.2 准备阶段: 初始化addCtx.AO S4.3 执行阶段: addCtx.AO 赋值 + 生成SCope = [ AO, add.[[scope]] ] , 其中add.[[scope]] = [addoneCtx.AO,globalCtx.VO] S4.3 执行完毕: addCtx对象 出栈销毁 即: S1 定义阶段: 生成function.[[scope]]属性, 值是其外部上下文对象的VO S2 调用阶段: 生成执行上下文对象Ctx = {} S3 调用后的准备阶段: 初始化AO对象, Ctx = { AO: {…} } S4 调用后的执行阶段: 赋值AO对象内部值 + 生成Scope属性: Ctx = { AO: {…}, Scope = [ AO, [[scope]] ], this } S5 执行完毕阶段: 上下文对象 出栈销毁 3 闭包的实质1 Q: 闭包的实质是什么 A: 闭包的实质，是作用域链机制的副作用； 只要子函数上下文中的Scope对象里的 [[scope]]仍然保存着父级的变量对象 那么即使父函数被销毁了，也依然可以在子函数中访问到 父级上下文的变量对象 4 闭包的作用1 for循环 函数数组 内部变量的正确绑定 123456789101112// 例1：for循环var data = []for (var i = 0; i &lt; 3; i++ )&#123; data[i] = function()&#123; console.log(i) &#125;&#125;data[0]() //3， 定义并执行data函数时，其作用域链为 Scope = [AO, gloContext.VO]data[1]() //3data[2]() //3 改成闭包的结果如下: 123456789101112var data = [];for (var i = 0; i &lt; 3; i++ )&#123; data[i] = !function(i)&#123; return function()&#123; console.log(i) &#125; &#125;(i)&#125;data[0]() //0，定义并执行data函数时， 其作用域链为 `Scope = [AO, 匿名函数Context.AO , globalContext.VO]`data[1]() //1data[2]() //2 5 闭包的问题1 闭包的缺点: 常驻内存会增大内存使用量, 增大内存消耗]]></content>
      <categories>
        <category>JS 作用域</category>
      </categories>
      <tags>
        <tag>JS 作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之 原型与原型链]]></title>
    <url>%2F2019%2F07%2F14%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[本文是对 原型和原型链的相关知识小结。 面向对象之 原型与原型链目录: 1 预读文档 2 原型 3 原型链 4 函数和对象 的创建过程 1 预读文档 1 JS深入之 从原型到原型链 阅读原因: 原型和原型链概念的最佳介绍博文 2 JS中先有Object还是先有Function 阅读原因: 关于Object和Function的关系介绍 3 深度解析原型中的各个难点 阅读原因: Object和Function的关系很清晰 2 原型 1 Q: 什么是原型 A: S1 JS中，每个函数都有一个prototype属性，指向一个对象 S2 JS中，每个对象都有一个proto属性，指向一个对象 S3.1 我们知道，通过构造函数B，可以创建出实例对象C S3.2 构造函数B也是函数，所以当然也有 prototype属性 S3.3 实例对象C也是对象，所以当然也有 proto属性 S3.4 特殊的是，实例对象.__proto__ = 构造函数.__prototype, 都指向同一个原型对象A S4.1 实例对象C可以读取原型对象A上的属性和方法 S4.2 原型对象A有一个constructor属性，指向其关联的构造函数 用代码表示为: 1234567891011function Person() &#123; // 构造函数: Person ......&#125;let person = new Person() // 实例对象: personconsole.log(person.__proto__ === Person.prototype) // trueconsole.log(Person.prototype.constructor === Person) // true// Object.getPrototypeOf方法,可以获得实例对象的 原型对象console.log(Object.getPrototypeOf(person) === Person.prototype) // true 用一张图表示为: 实例对象、构造函数、原型对象关系 3 原型链 1 Q: 什么是原型链 A: S1.1 每个对象都有一个原型对象，原型对象也有原型对象，一层一层的原型对象就构成了原型链 S1.2 原型链的顶层对象是Object.prototype, 再往上则: Object.prototype.__proto__ 为 null S1.3 通过原型链，可以实现属性的共享和继承 S2 原型链的属性查找机制: 会依次在 实例对象-&gt; 原型对象A-&gt; A.__proto_对象-&gt; …..-&gt; Object.prototype中查找属性 S3 原型链的属性修改机制: 只会修改实例对象 本身的属性，如果不存在，则添加该属性 蓝色部分表示为: 原型链 4 函数和对象 的创建过程 1 Object.prototype S1 浏览器内置就实现的 key-value对象，它是一个对象 + 对象都有proto属性 S2 ES规定了: Object.prototype.__proto = null 2 Function.prototype S1 浏览器内置就实现的 key-value S2 规定了: Function.prototype.__proto__ = Object.prototype 3 Function构造函数 S1 构造函数对象 具有 proto属性 + prototype属性 S2 规定了: Function.__proto__ = Function.prototype，就只是这么规定的 S3 Function.prototype = Function.prototype 4 Object构造函数 S1 构造函数对象 具有 proto属性 + prototype属性 S2 Object构造函数 是由Function构造出的实例对象，所以 Object.__proto__ = Function.prototype S3 Object.prototype = Object.prototype 5 自定义函数的 实例对象 S1 实例对象fn是由 自定义构造函数Fn构造出的，所以 fn.__proto__ = Fn.prototype S2 自定义构造函数Fn 是由 Function构造的实例，所以 Fn.__proto__ = Function.prototype ，且Fn.prototype = Fn.prototype S3 Fn.prototype是一个对象，它是由Object构造出的实例，所以 Fn.prototype.__proto__ = Object.prototype 综合上面所有内容，一张经典图理解为:]]></content>
      <categories>
        <category>JS 原型</category>
      </categories>
      <tags>
        <tag>JS 原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2019%2F04%2F21%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[这周用hexo和github Pages搭建了自己的静态博客，这是过程中的小结记录。 因为主要是用来给自己备忘的，所以只是直接记录了相关的参考文档。 一 博客搭建过程1 Q: 如何搭建博客 S1 实现基本博客功能，参考这个文档即可: hexo教程：github page+独立域名搭建(1) S2 配置博客主题，依次参考以下文档: 01 hexo的next主题个性化配置教程 02 next官方文档 03 底部文字居中 04 代码块复制功能 S3 利用git分支进行多终端工作，具体可见: hexo教程:基本配置+更换主题+多终端工作+coding page部署分流(2) S4 发布步骤,代码见下: 1234567hexo cleanhexo s --debughexo dhexo g]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
