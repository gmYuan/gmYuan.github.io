<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[性能之 防抖和节流]]></title>
    <url>%2F2019%2F11%2F23%2F%E6%80%A7%E8%83%BD%E4%B9%8B%20%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[本文介绍了防抖和节流的 相关知识点。 性能之 防抖和节流目录 1 预读文档 2 防抖实现 3 节流实现 一 预读文档 1 阅读文档有 1 JS专题之 跟着underscore学防抖 2 JS专题之 跟着underscore学节流 阅读原因: 直接参考文档 3 函数防抖与函数节流 阅读原因: 节流实现很好，最后推荐网站值得一看 二 防抖 1 Q: 什么是防抖(debounce) A: S1 当用户的操作会引起 频繁的JS计算/网络请求等时，就要对其事件响应回调进行频率限制，以保证性能 S2 防抖的限制原理类似于 每次法师读大过程中再次放大, 就会重新进行施法计时 2 Q: 实现防抖的难点 A: S1 如何重新进行施法计时: 清除之前已有的的回调计时 + 进行新的回调计时 3 Q: 如何实现防抖 A: 防抖分为 非立即执行版 和 立即执行版, 代码见下: 1234567891011121314151617181920212223242526272829303132333435// 1 非立即执行版function deounce(func, wait) &#123; var timer return function() &#123; var self = this, args = arguments // 绑定因异步延时 丢失的this 和 event对象 clearTimeout(timer) timer = setTimeout(function() &#123; func.apply(self, args) &#125;, wait) &#125;&#125;// 2 立即执行版: 一开始立即执行 + 之后每次防抖function debounce(fn, wait, immediate) &#123; var timer return function() &#123; var self = this, args = arguments clearTimeout(timer) if (immediate) &#123; timer = setTimeout(function()&#123; // S1 不断清除timer + 后续实质为节流 timer = null &#125;, wait) if (!timer) &#123; fn.apply(self, args) &#125; &#125; else &#123; // 非立即执行时，执行原逻辑 timer = setTimeout(function()&#123; fn.apply(self, args) &#125;, wait) &#125; &#125;&#125; 三 节流 1 Q: 什么是节流(throttle) A: S1 一段时间内不管触发多少次事件，都只按固定的频率响应对应回调 S2 防抖的核心是 不满足就重置, 节流的核心是 不满足就忽略 2 Q: 如何实现节流 A: S1 方法1: 时间戳法, 代码见下 12345678910111213function throttle(fn, wait) &#123; let previos = 0 let self, args return function() &#123; self = this, args = arguments let now = +new Date() if (now - previous &gt;= wait) &#123; fn.apply(self, args) previous = now &#125; &#125;&#125; S2 方法2: 定时器法, 代码见下 1234567891011function throttle(fn, wait) &#123; let timer, self, args return function() &#123; timer = setTimeout(function()&#123; timer = null &#125;, wait) if (!timer) &#123;fn.apply(self, args)&#125; &#125;&#125; S3 最终综合版本见下 1234567891011121314151617181920function throttle(fn, wait) &#123; let timeout let previous = 0 return function () &#123; var context = this, args = arguments var curr = +new Date() clearTimeout(timeout) //总是干掉事件回调 if(curr - previous &gt;= wait)&#123; fn.apply(context, args) previous = curr &#125; else &#123; timeout = setTimeout(function()&#123; //让方法在脱离事件后也能执行一次 fn.apply(context, args) &#125;, wait) &#125; &#125;&#125;]]></content>
      <categories>
        <category>性能 防抖节流</category>
      </categories>
      <tags>
        <tag>性能 防抖节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之 symbol类型详解]]></title>
    <url>%2F2019%2F11%2F23%2FES6%E4%B9%8B%20symbol%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍了ES6中 symbol类型 相关知识点。 ES6之 symbol类型详解目录: 1 预读文档 2 symbol含义 与 作用 3 symbol常用语法 和 内部属性 1 预读文档 1 阮一峰ES6教程_symbol 阅读原因: 直接参考文档 2 symbol含义 与 作用 1 Q: 什么是symbol A: S1 ES6引入的一种新的数据类型 + 可以创建独一无二的值 2 Q: symbol有什么作用 A: symbol用作对象的key S1 因为可以创建独一无二的值，所以可以解决 对象属性同名冲突/覆盖问题 S2 symbol用作对象的key: 因为用symbol作为对象的key,不会被 for..in/for..of/object.keys()遍历到，所以可以形成类似 内部私有属性的效果 代码分别见下: 12345678910111213141516171819202122232425262728293031323334353637383940414243// 例1const allCourseType = &#123; English: Symbol()&#125;;function getCourse(courseType) &#123; switch (courseType) &#123; case allCourseType.English: console.log('这节是英语课') break ...... &#125;&#125;getCourse(allCourseType.English)// 例2let coin = Symbol('coin')class Collection &#123; constructor() &#123; this[coin] = 0 &#125; add(item) &#123; this[this[coin]] = item; this[coin]++; &#125; static coinNum(instance) &#123; return instance[size]; &#125;&#125;let x = new Collection()Collection.coinNum(x) // 0x.add('foo');Collection.coinNum(x) // 1Object.keys(x) // ['0']Object.getOwnPropertyNames(x) // ['0']Object.getOwnPropertySymbols(x) // [Symbol(coin)] 3 symbol常用语法 和 内部属性 1 Q: symbol常用语法有哪些 A: 具体见参考文档即可]]></content>
      <categories>
        <category>ES6 symbol</category>
      </categories>
      <tags>
        <tag>ES6 symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型判断之 类型判断方法]]></title>
    <url>%2F2019%2F11%2F12%2F%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B9%8B%20%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文主要介绍了类型判断的函数实现。 类型判断之 类型判断方法目录: 1 预读文档 2 实现 类型判断函数 3 判断变量是否是 数组类型 1 预读文档 1 JS专题之 类型判断(上) 阅读原因: 直接参考文档 2 实现 类型判断函数 1 Q: 写一个函数，可以实现变量的 类型判断 A: S1 判断基本类型, 可以使用 typeof操作符: String/Number/Boolean/undefined + function + object(null) S2 判断引用类型, 可以使用 Object.prototype.toString操作符: 返回形式例为[object Date] S3 具体思路为: 生成类型映射对象 + 兼容IE6单独判断null/undefined + 根据typeof/object.pty.toString()返回对应数据类型 代码实现如下: 1234567function type(val) &#123; return Object.prototype.toString.call(val).toLowerCase().split(' ')[1].slice(0,-1)&#125;// test caselet str = "123"type(str) // "string" 具体一点的实现方法为: 123456789101112131415161718let typeObjMap = &#123;&#125;"String Number Boolean Null Undefined Array Function Object Error Date RegExp".split(" ").map((item) =&gt; &#123; typeObjMap['[object ' + item + ']'] = item.toLowerCase()&#125;)console.log(typeObjMap)function getVariableType(o) &#123; if (o == null) &#123; return '' + o &#125; let result = (typeof o === 'object' || typeof o === 'function' ? typeObjMap[Object.prototype.toString.call(o)] || 'object' : typeof o) return result&#125;// test caselet arr = [1, 2]getVariableType(arr) // array 3 判断变量是否是 数组类型 1 Q: 如何判断变量是否是数组类型 A: S1 通过Array.isArray()方法 S2 通过instanceof S3 通过Objdect.prototype.toString.call()方法 S4 通过constructor，如果xx是数组，那么 xx.constructor === Array 12345678910111213function fn() &#123; console.log(Array.isArray(arguments)) //false 因为arguments是类数组，不是数组 console.log(Array.isArray([1,2,3,4])) //true console.log(arguments instanceof Array) //fasle console.log([1,2,3,4] instanceof Array) //true console.log(Object.prototype.toString.call(arguments)) //[object Arguments] console.log(Object.prototype.toString.call([1,2,3,4])) //[object Array] console.log(arguments.constructor === Array) //false arguments.constructor = Array console.log(arguments.constructor === Array); //true]]></content>
      <categories>
        <category>类型判断</category>
      </categories>
      <tags>
        <tag>类型判断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之 对象继承方式]]></title>
    <url>%2F2019%2F11%2F12%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%20%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本篇主要介绍 JS中面向对象继承的实现方法。 面向对象之 对象继承方式目录: 1 预读文档 2 继承方法实现 1 预读文档 1 JS深入之 继承的多种方式和优缺点 阅读原因: 直接参考文档 2 继承方法实现 1 Q: JS中实现 对象继承的方式有哪些 A: S1 方法1: 原型链继承: child.pty = new Parent() 123456789101112131415161718function Parent() &#123; this.prices = [20, 40]&#125;Parent.prototype.showPrice = function() &#123; console.log(this.prices)&#125;function Child() &#123;&#125;Child.prototype = new Parent()let ex1 = new Child() // ex1.__ptot0__ =&gt; Child.pty === obj: &#123;prices&#125; =&gt; Parent.ptylet ex2 = new Child()ex1.prices.push(60)ex2.showPrice() // [20, 40, 60]// 缺点: 子类不能传入参数 + 引用类型数据在子类实例中会 互相影响 S2 方法2: 经典继承: Parent.call(this) 123456789101112131415161718192021function Parent(price) &#123; let result = [1] result.push(price) this.prices = result&#125;Parent.prototype.showPrice = function() &#123; console.log(this.prices)&#125;function Child(price) &#123; Parent.call(this, price)&#125;let ex1 = new Child(2) // ex1.prices = [1, 2] + ex1.__proto__ === Child.ptylet ex2 = new Child(3) // ex2.prices = [1, 3] + ex2.pro === Child.ptyconsole.log(ex1.prices) // [1, 2]console.log(ex2.prices) // [1, 3]console.log(ex1.showPrice) // undefined// 缺点: 子类实例不能访问 父类原型上的方法 + 每次创建子类实例都会 调用一次父类 S3 方法3: 组合继承: child.pro = new Parent + Parent.call(this) 123456789101112131415161718192021222324function Parent(name) &#123; this.name = name this.ages = [1,3]&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name) &#123; Parent.call(this, name)&#125;Child.prototype = new Parent() // child.pty === &#123;name, ages&#125;, child.pty.__proto__ === Parent.prototypeChild.prototype.constructor = Child;let ex1 = new Child('name1') let ex2 = new Child('name2')ex1.ages.push(5)console.log(ex1) // &#123;ages: [1, 3, 5], name: "name1"&#125;console.log(ex2) // &#123;ages: [1, 3], name: "name2"&#125;ex1.getName() // name1// 缺点: 子类实例 和 子类原型对象上 都会调用一次父类方法, 实例和原型对象上存在同名参数 S4 方法4: 原型式继承: object.create的模拟实现 12345678910111213141516function createObj(parentObj) &#123; function child() &#123;&#125; child.prototype = parentObj return new child()&#125;let p1 = &#123;name: 'test', ages: [2,4]&#125;let ex1 = createObj(p1)let ex2 = createObj(p1)ex1.ages.push(6)console.log(ex1.ages) // [2,4,6]console.log(ex2.ages) // [2,4,6]// 缺点: 同原型链继承 S5 方法5: 寄生组合式继承: Parent.call(this) + 原型对象 原型式继承 1234567891011121314151617181920212223function Parent(name) &#123; this.name = name this.ages = [2,3]&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name) &#123; Parent.call(this, name)&#125;let temp = function()&#123;&#125;temp.prototype = Parent.prototypeChild.prototype = new temp() // 不会再次执行Parent一次let ex1 = new Child('name1') let ex2 = new Child('name2') ex1.ages.push(4)console.log(ex1) // &#123; ages: [2, 3, 4], name: "name1" &#125;console.log(ex2) // &#123; ages: [2, 3], name: "name2" &#125;ex1.getName() // name1 ES6 Class的写法见下 12345678910111213141516171819class Parent&#123; constructor(name)&#123; this.name = name &#125; getName() &#123; console.log(this.name) &#125;&#125;class Child extends Parent&#123; constructor(name)&#123; super(name) // super关键字作用: 调用继承 父类的实例属性/方法 this.age = 20 &#125; playgame()&#123; console.log('Men like playing games') &#125;&#125;]]></content>
      <categories>
        <category>对象 继承</category>
      </categories>
      <tags>
        <tag>对象继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之 迭代器 + 生成器 详解]]></title>
    <url>%2F2019%2F11%2F10%2FES6%E4%B9%8B%20%E8%BF%AD%E4%BB%A3%E5%99%A8%20%2B%20%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍了ES6中 迭代器和生成器 相关知识点。 ES6之 迭代器 + 生成器 详解目录: 1 预读文档 2 迭代器 3 生成器 1 预读文档 1 深入理解ES6 2 Iterator 和 for…of 循环 3 对象的扩展 4 变量的解构赋值 阅读原因: 全面介绍了迭代器 2 迭代器 1 Q: 迭代和循环的区别是什么 A: S1 循环: 明确的起止范围 S2 迭代: 不明确结束范围 2 Q: 模拟一个迭代器实现 A: 函数 -&gt; 对象: next方法 -&gt; 返回结果对象 123456789101112131415161718192021222324function creatorIterator(arr) &#123; let i = 0 // 必须 return &#123; next() &#123; let done = (i &gt;= arr.length) let value = (done ? undefined : arr[i++] ) return &#123; done, value &#125; &#125; &#125;&#125;let iterator = creatorIterator([1, 2, 3])console.log(iterator.next()) // "&#123; value: 1, done: false &#125;"console.log(iterator.next()) // "&#123; value: 2, done: false &#125;"console.log(iterator.next()) // "&#123; value: 3, done: false &#125;"console.log(iterator.next()) // "&#123; value: undefined, done: true &#125;"// 之后的所有调用console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 3 剩余参数rest 1 Q: 剩余参数rest有哪些使用场景 A: S1 剩余参数: 可以把多个独立的参数 合并到一个数组中 所以可用于 函数传参，替代arguments对象 12345678// 例1: 使用示例function add(...values) &#123; let sum = 0 values.reduce( (pre, cur) =&gt; &#123;return sum = pre + cur&#125;) return sum&#125;add(1, 2, 3) // 6 S2 剩余参数 + 解构赋值 123456789// 例2: 数组解构赋值let colors = [ "red", "green", "blue" ]let [ firstColor, ...restColors ] = colorsconsole.log(firstColor) // "red"console.log(restColors.length) // 2console.log(restColors[0]) // "green"console.log(restColors[1]) // "blue" 4 扩展运算符… 1 Q: 扩展运算符… 有哪些使用场景 A: S1 用于函数传参，把一个数组分解成各个单独参数 123// 例1: 替代 apply方法调用函数Math.max.apply(null, [14, 3, 77]) // ES5 的写法Math.max(...[14, 3, 77]) // ES6 的写法, 等同于 Math.max(14, 3, 77) S2 用于数组/对象 1234567891011// 例2: 浅拷贝数组const a1 = [1, 2]const a2 = [...a1] // 方法1: 扩展运算符方法const [...a2] = a1 // 方法2: 解构赋值 + 剩余参数法// 例3: 合并数组const arr1 = ['a', 'b'];const arr2 = ['c'];[...arr1, ...arr2] // [ 'a', 'b', 'c' ] 5 解构赋值 1 Q: 解构赋值 有哪些使用场景 A: S1 对象解构赋值 + 默认参数 12345678let node = &#123; type: "Identifier"&#125;let &#123; type: localType, name: localName = "bar" &#125; = nodeconsole.log(localType) // "Identifier"console.log(localName) // "bar" S2 数组解构赋值 1234567891011// 例1: 获取特定index值let colors = [ "red", "green", "blue" ]let [ , , thirdColor ] = colorsconsole.log(thirdColor) // "blue"// 例2: 解构赋值 + 默认参数let colors = [ "red" ]let [ firstColor, secondColor = "green" ] = colorsconsole.log(firstColor) // "red"console.log(secondColor) // "green" S3 函数参数解构赋值 + 默认参数: 用以明确 对象参数的具体内容 12345678function setCookie(name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;) &#123; // ...&#125;// 例2function setCookie(name, value, &#123; secure = false, path = "/", domain = "example.com"&#125; = &#123;&#125;) &#123; // ...&#125;]]></content>
      <categories>
        <category>迭代器 生成器</category>
      </categories>
      <tags>
        <tag>迭代器 生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之 默认参数 + 三点运算符 + 解构赋值 详解]]></title>
    <url>%2F2019%2F11%2F10%2FES6%E4%B9%8B%20%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%2B%E4%B8%89%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6%2B%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍了ES6中 默认参数、三点运算符、解构赋值 相关知识点。 ES6之 默认参数 + 三点运算符 + 解构赋值 详解目录: 1 预读文档 2 默认参数 3 剩余参数rest 4 扩展运算符… 5 解构赋值 1 预读文档 1 深入理解ES6 2 函数的扩展 3 对象的扩展 4 变量的解构赋值 阅读原因: 全面介绍了默认参数、剩余参数、扩展运算符 2 默认参数 1 Q: 默认参数有哪些使用场景 A: S1 用于函数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 例1: 函数默认参数, 用于设置参数默认值function log(x, y = 'World') &#123; console.log(x, y)&#125;console.log('Hello') // Hello Worldconsole.log('Hello', 'China') // Hello Chinaconsole.log('Hello', '') // Hello// 例2: 每次函数调用时都会创建一个新的 默认参数对象function append(value, array = []) &#123; array.push(value); return array;&#125;append(1); //[1]append(2); //[2], not [1, 2]// 例3:非尾部的 参数默认值，实际上这个参数是无法省略的function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined]f(, 1) // 报错,不能直接省略默认参数f(undefined, 1) // [1, 1]f(null, 3) // [null, 3]// 例4:默认参数 + length属性: 遇到默认参数时就会忽略之后的形参数(function (a, b, c = 5) &#123;&#125;).length // 2(function (a, b = 1, c) &#123;&#125;).length // 1// 例5: 函数默认参数 + arguments： arguments只与实参有关，和形参/默认参数无关function mixArgs(first, second="b") &#123; console.log(arguments.length) console.log(first === arguments[0]) console.log(second === arguments[1]) first = "c" second = "d" console.log('first:'+ first) console.log('second:' +second) console.log('arguments[0]:' + arguments[0]) console.log('arguments[1]:' + arguments[1])&#125;mixArgs("a"); //实际调用// 输出结果1 //arguments的值只有一个传入的实参 first=atruefalse first: csecond: darguments[0]: aarguments[1]: undefined //只与实参有关// 例6: 参数默认值表达式let value = 5function getValue() &#123; return value++&#125;function add(first, second = getValue()) &#123; return first + second&#125;console.log(add(1, 1)) // 2console.log(add(1)) // 6console.log(add(1)) // 7 3 剩余参数rest 1 Q: 剩余参数rest有哪些使用场景 A: S1 剩余参数: 可以把多个独立的参数 合并到一个数组中 所以可用于 函数传参，替代arguments对象 12345678// 例1: 使用示例function add(...values) &#123; let sum = 0 values.reduce( (pre, cur) =&gt; &#123;return sum = pre + cur&#125;) return sum&#125;add(1, 2, 3) // 6 S2 剩余参数 + 解构赋值 123456789// 例2: 数组解构赋值let colors = [ "red", "green", "blue" ]let [ firstColor, ...restColors ] = colorsconsole.log(firstColor) // "red"console.log(restColors.length) // 2console.log(restColors[0]) // "green"console.log(restColors[1]) // "blue" 4 扩展运算符… 1 Q: 扩展运算符… 有哪些使用场景 A: S1 用于函数传参，把一个数组分解成各个单独参数 123// 例1: 替代 apply方法调用函数Math.max.apply(null, [14, 3, 77]) // ES5 的写法Math.max(...[14, 3, 77]) // ES6 的写法, 等同于 Math.max(14, 3, 77) S2 用于数组/对象 123456789101112// 例2: 浅拷贝数组const a1 = [1, 2]const a2 = [...a1] // 方法1: 扩展运算符方法const [...a2] = a1 // 方法2: 解构赋值 + 剩余参数法// 例3: 合并数组const arr1 = ['a', 'b'];const arr2 = ['c'];[...arr1, ...arr2] // [ 'a', 'b', 'c' ] 5 解构赋值 1 Q: 解构赋值 有哪些使用场景 A: S1 对象解构赋值 + 默认参数 12345678let node = &#123; type: "Identifier"&#125;let &#123; type: localType, name: localName = "bar" &#125; = nodeconsole.log(localType) // "Identifier"console.log(localName) // "bar" S2 数组解构赋值 12345678910// 例1: 获取特定index值let colors = [ "red", "green", "blue" ]let [ , , thirdColor ] = colorsconsole.log(thirdColor) // "blue"// 例2: 解构赋值 + 默认参数let colors = [ "red" ]let [ firstColor, secondColor = "green" ] = colorsconsole.log(firstColor) // "red"console.log(secondColor) // "green" S3 函数参数解构赋值 + 默认参数: 用以明确 对象参数的具体内容 12345678function setCookie(name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;) &#123; // ...&#125;// 例2function setCookie(name, value, &#123; secure = false, path = "/", domain = "example.com"&#125; = &#123;&#125;) &#123; // ...&#125;]]></content>
      <categories>
        <category>默认参数 三点运算符 解构赋值</category>
      </categories>
      <tags>
        <tag>默认参数 三点运算符 解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之 this + 箭头函数详解]]></title>
    <url>%2F2019%2F11%2F10%2FES6%E4%B9%8B%20this%20%2B%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍了ES6中 this和箭头函数 相关知识点。 ES6之 this + 箭头函数详解目录: 1 预读文档 2 什么是this 3 为什么要有this 4 this指向规则 5 箭头函数其他特点 1 预读文档 1 阮一峰— this关键字 2 MDN— this关键词 3 掘金— this、apply、call、bind 阅读原因: 全面介绍了this的相关知识和易错点 4 冴羽—— ES6系列之 箭头函数 5 什么时候不能使用箭头函数 阅读原因: 箭头函数相关知识点介绍 2 什么是this 1 Q: 什么是this A: S1 this是函数执行上下文中指向的 一个对象 S2 不同的函数调用方法，this指向的对象也不同 3 为什么要有this 1 Q: 为什么要有this A: S1 为了实现函数方法的复用, 举例: 12345678910111213141516171819202122function eating()&#123; // 创建一个eating函数,内部使用了this console.log(this.name + ' is eating')&#125;// S2.1 有一个人想执行eating()方法，他可以这样实现let person1 = &#123; name: 'klay', age: 20, eat: eating&#125;person1.eat() // 输出'klay is eating'// S2.2 如果有另一个人也想执行eating()方法，那么他可以如下实现let person2 = &#123; name: 'teddy', age: 21, eat: eating&#125;person2.eat() // 输出'teddy is eating' 4 this指向规则 1 Q: this指向对象 有哪些常见情况 A: S1 全局环境 + 非严格模式: this指向 window对象; 全局环境 + 严格模式: this指向 undefined 这种情况，可以理解成 test.call(undefined) 1234567this.b = 'test'console.log(this.b === window.b) //turefunction test()&#123; console.log(this)&#125;test() //window S2 函数作为对象方法调用: this指向 该对象 这种情况，可以理解成 obj.getName.call(obj) 1234567var obj = &#123; name: 'klay', getName: function()&#123; console.log(this.name) &#125;&#125;obj.getName() //klay 特殊情况1: 函数作为嵌套对象 内部的方法调用: this指向 内部对象, 可以理解成 obj1.obj2.getName.call(obj2) 1234567891011121314function naming()&#123; console.log(this.name)&#125;var obj1 = &#123; name:'klay', getName: naming, obj2:&#123; name:'inner', getName: naming &#125;&#125;obj1.obj2.getName() //inner 特殊情况2: 函数作为数组成员调用: this指向 该数组对象 (因为数组是特殊的对象) 1234567function fn1()&#123; console.log(this)&#125;var fn2,fn3var arr = [fn1,fn2,fn3]arr[0]() //arr 特殊情况3: 对象方法赋值给一个函数A，调用函数A时，this指向window 12345678910var name = 'outer'var obj1 = &#123; name:'klay', getName: function()&#123; console.log(this.name) &#125;&#125;var outer = obj1.getNameouter() //outer 特殊情况4: 对象方法和运算符（布尔/算数/赋值等）一起使用，this对象指向全局对象 123456789var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;(false || obj.foo)() //window(obj.foo, obj.foo)() //window(obj.foo = obj.foo)() //window 特殊情况5: 对象里的函数A含有函数B，函数B执行时，B内部的this 指向window对象 12345678910var obj1 = &#123; f1: function()&#123; console.log(this) var f2 = function()&#123; console.log(this) &#125;() &#125;&#125;obj1.f1() //obj1 window 特殊情况6: 回调函数A中 传入的函数B内部使用this, this会被修改成 window对象/DOM元素等 类似的还有内置函数的回调，如setTimeout()、foreach()、事件监听回调函数等 12345678910111213var a = 'global'var obj1 = &#123; a:2, foo()&#123; console.log(this.a) &#125;&#125;function doFoo(fn)&#123; fn()&#125;doFoo(obj1.foo) //"global" 特殊情况7: 原型链和 getter/setter中的 this，都指向调用方法的对象（具体见MDN） S3 函数调用时显式绑定指向对象(call/apply/bind): 此时this指向 传入的对象 1234567891011121314function foo()&#123; console.log(this.a)&#125;var obj1 = &#123; a:2&#125;var bar = function()&#123; foo.call(obj1)&#125;bar() //2bar.call(window) //2 因为bar函数内部 已经手动固定指向了obj1对象, 不会再改变 S4 使用new创建对象实例时，this指向新创建的对象实例 123456function Foo(a)&#123; this.a = a&#125;var bar = new Foo(2)console.log(bar.a) //2 以上4种情况的优先级是: new构造函数 &gt; 显式调用 &gt; 默认对象调用 &gt; 全局（函数）调用 S5 使用箭头函数，其this 就是 外层函数调用时的this指向对象 箭头函数没有this, 箭头函数的this值 遵循词法作用域的查找规则（就像是一个普通变量） 1234567891011function foo()&#123; return ()=&gt;&#123; console.log(this.a) &#125;&#125;var obj1 = &#123;a:1&#125;;var obj2 = &#123;a:2&#125;;var bar = foo.call(obj1)bar.call(obj2) //1,不是2!, 因为 箭头函数的this 继承自foo()第一次调用时的this指向对象 5 箭头函数其他特点 1 Q: 箭头函数和 ES5函数有哪些不同点 A:S1 箭头函数 没有this / super / arguments, 也没有new.target绑定, 所以这些值的查找规则 遵循词法作用域 S2 箭头函数不能使用new调用: 箭头函数没有 [[Construct]]方法，因此不能被用为构造函数, 使用new 调用箭头函数会报错 S3 箭头函数没有原型: 也就是没有prototype属性 S4 箭头函数不能更改this, 因此虽然可以使用call/apply/bind方法，但this值不会发生改变 S5 箭头函数 不允许重复的具名参数: 传统函数只有在严格模式下才禁止这种重复]]></content>
      <categories>
        <category>this 箭头函数</category>
      </categories>
      <tags>
        <tag>this 箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之 var + let + const详解]]></title>
    <url>%2F2019%2F11%2F10%2FES6%E4%B9%8B%20var%2Blet%2Bconst%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍了ES6中 let和const相关知识点。 ES6之 var + let + const详解目录: 1 预读文档 2 声明变量 和 非声明变量 3 let 和 var 4 let 和 const 5 let的常见使用场景 1 预读文档 1 MDN的 var关键字 阅读原因: 介绍了 声明变量和未声明变量之间的区别，以及易错点 2 深入理解ES6 P10~20 3 阮一峰—let 和 const 命令 4 方应杭—理解 let 阅读原因: 介绍了 let/const/var 相关知识点 2 声明变量 和 非声明变量 1 Q: 声明变量 和 非声明变量 的区别是什么 A: S1 作用域不同: 用var声明的变量，其作用域是当前执行上下文 (函数/全局), 而非声明变量（无var 创建的变量），其作用域 是全局 12345678function x() &#123; y = 1; var z = 2;&#125;x();console.log(y); // 打印"1" , 因为y是非声明变量，因此是一个全局变量console.log(z); // 抛出ReferenceError，因为z所属作用域为x函数 S2 创建变量的时间不同: 用var声明的 简单类型变量，在声明时就会被创建 + 变量值初始化为undefined, 而 非声明变量（无var创建的变量），只有在 执行赋值操作时才会被创建 12console.log(a); // 抛出ReferenceError，因为非声明变量，只有赋值才会创建console.log('still going...'); // 永不执行，因为上一句报错了 2 Q: 写出下面 var声明变量的结果 S1 12345678910111213141516// 例1var x = y, y = 'A'console.log(x + y) // undefinedA, var变量提升 &amp; x= y默认值(此时为undefined) &amp; y='A'// 例2var a,b = a = 'A' //合法, var变量提升 &amp; 从右到左执行赋值语句// 例3var x = 0function f()&#123; var x = y = 1; // 相当于var x + 从右到左执行赋值，所以y是 非声明变量/全局变量&#125;f()console.log(x, y) // 0, 1 S2 嵌套函数内赋值非声明变量， 逐向外层寻找直到全局，有就覆盖赋值，无则新建全局 1234567891011121314151617181920var x = 0; console.log(typeof z) // undefined，因为z还不存在function a() &#123; var y = 2 console.log(x, y) // 0 2 function b() &#123; x = 3; // 全局变量x被赋值为3，不生成新的全局变量 y = 4; // 已存在的外部函数的y变量被赋值为4，不生成新的全局变量 z = 5; // 创建新的全局变量z &#125; b() console.log(x, y, z) // 3 4 5&#125;a() // 调用a时同时调用了bconsole.log(x, z); // 3 5console.log(typeof y); // undefined，因为y是a函数的local变量 3 let 和 var 1 Q: let 和 var 的区别有哪些 A: S1 具有块级作用域: let/const声明的变量，具有块级作用域的限制， 而var声明的变量则没有 1234567&#123; let a = 10; var b = 20;&#125;a // ReferenceError: a is not definedb // 1 S2 不会变量声明提升: let/const声明的变量，不会进行变量声明提升, 而var声明的变量会有 12345678// varconsole.log(foo) // 输出undefinedvar foo = 2// letconsole.log(bar) // 报错ReferenceErrorlet bar = 2 S3 禁止重复声明: 用let/const声明的变量，不可被重复声明, 而var声明的变量可以被重复声明 12345678910111213141516171819//例1var count = 30if (condition)&#123; let count = 40 //合法，因为同名变量不在同一作用域内&#125;//例2function func(arg) &#123; let arg // 报错，不可重复声明&#125;// 例3function func(arg) &#123; &#123; let arg // 不报错，不在同一作用域 &#125;&#125; S4 存在暂时性死区: let/const声明的变量，存在暂时性死区, 而var声明的变量则不存在 TDZ, 可以理解为: let声明 提升了变量的创建+暂存在死区内，且不提升初始化和赋值操作，所以在执行到 初始化语句之前都无法访问 123456789101112131415161718192021//例1if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束，初始化值为undefined console.log(tmp); // undefined tmp = 123; // 赋值语句 console.log(tmp); // 123&#125;//例2typeof x; //报错，ReferenceErrorlet x//例3var x = x //不报错let x = x // ReferenceError: x is not defined， let声明的变量在初始化执行完前不可访问 S5 不绑定到 全局作用域 12345var value = 1console.log(window.value) // 1let value = 1console.log(window.value) // undefined 4 let 和 const 1 Q: let 和 const 的区别有哪些 S1 const变量 需要在声明时就进行初始化, 而let则不一定 123const maxItems = 30 // 有效的常量const name // 语法错误：未进行初始化 S2 const声明的变量 不能被重复赋值, 而let则不一定 123const maxItems = 5maxItems = 6 // 抛出错误 PS: const声明一个对象时，只要指向的地址未发生变化，那么修改里面的成员值是合法的 12345678910const person = &#123; name: "Nicholas"&#125;person.name = "Greg" // 正常person = &#123; // 抛出错误 name: "Greg"&#125; 5 let的常见使用场景 1 Q: let + for循环情况 A: S1 for循环中, let定义的变量仅在内部可用，一旦循环结束，该变量在任意位置都不可访问 12345for (let i =0; i &lt; 10 ; i++)&#123; console.log(i)&#125;console.log(i) // i在此处无法访问，用var则在此处可访问 S2 循环中的函数计数，可用let在每次迭代时创建一个新绑定，替换以前的 IIFE 123456789101112131415161718192021222324252627282930var a = []for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i) &#125;&#125;a[6]() //10,因为调用时调用栈是 fn1匿名函数——全局作用域// ES5解决方法var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = !function(arg)&#123; return function()&#123; console.log(arg) &#125; &#125;(i)&#125;//a[6]() //6//ES6解决方法var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); //6,因为 每一次循环的i其实都是一个新的变量 ES6的解决原理是: (1) 在 for (…) 的圆括号内，建立一个隐藏的作用域 (2) 每次迭代循环时都创建一个新变量，并以之前迭代中 同名变量的值将其初始化, 即： 123456789101112131415161718//伪代码(let i = 0) &#123; funcs[0] = function() &#123; console.log(i) &#125;; &#125;(let i = 1) &#123; funcs[1] = function() &#123; console.log(i) &#125;;&#125;(let i = 2) &#123; funcs[2] = function() &#123; console.log(i) &#125;;&#125;;]]></content>
      <categories>
        <category>let const</category>
      </categories>
      <tags>
        <tag>let const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之 instanceof模拟实现]]></title>
    <url>%2F2019%2F11%2F10%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%20instanceof%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文模拟实现了 JS里 instanceof关键字的功能。 面向对象之 instanceof模拟实现目录: 1 预读文档 2 instanceof 本质和实现 3 instanceof 再次理解原型链 1 预读文档 1 instanceof原理 2 关于instanceof和原型链 阅读原因: 直接参考文档 2 instanceof 本质 和 实现 1 Q: instanceof的实现原理是什么 A: S1 instaceof的实现原理，是递归查找原型链的过程 123obj1 instanceof Fn// 不断查找obj.__proto__.__proto__......, 只有其中有一环指向Fn.prototype, 则为true 2 Q: 手写出instanceof的实现代码 123456789101112131415mockInstanceof = function(left, right) &#123; // left表示左侧对象(实例)，right表示右侧函数对象参数 let src = left.__proto__ let target = right.prototype while(true) &#123; if (src === null) &#123; // 原型链对象遍历到顶层时 return false &#125; if (src === target) &#123; // 与显式对象严格相等时 return true &#125; src = src.__proto__ // 递归遍历原型链 &#125;&#125; 3 instanceof 再次理解原型链 1 Q: 原型链的递归值分别是哪些, 或者说，原型链的完整流程是什么 A: 3句话来理解下图即可 S1 (实例)对象 都有proto属性 S2 构造函数对象 同时具有 proto属性 和 prototype属性 S3 proto可以近似理解为 父子关系 最后以一张经典图结束]]></content>
      <categories>
        <category>instanceof</category>
      </categories>
      <tags>
        <tag>instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之 new的模拟实现]]></title>
    <url>%2F2019%2F11%2F10%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%20new%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文模拟实现了 JS里 new关键字的功能。 面向对象之 new的模拟实现目录: 1 预读文档 2 new 作用介绍 3 new 模拟实现 1 预读文档 1 JS深入之 new的模拟实现 阅读原因: 参考实现文档 2 new作用介绍 1 Q: new方法的 使用方法 和特点 是什么 A: S1 使用方法 和 特点见下 12345let ex1 = new Fn()// S1: 创建一个新对象obj, obj可以访问Fn.prototype的属性/方法 (即obj.__proto__ = Fn.prototype)// S2: 执行Fn(),其内部this指向 obj// S3: 判断Fn有无返回值: 有返回值则返回 Fn的返回值; 无返回值则返回 obj 3 new 模拟实现 1: Q: 手写出 new的模拟实现 A: S1 ES3的实现方法 1234567function mockNew() &#123; var Fn = [].shift.call(arguments) var obj = Object.create(Fn.prototype) var result = Fn.apply(obj, arguments) retrun typeof result === "object" ? result : obj&#125;]]></content>
      <categories>
        <category>new</category>
      </categories>
      <tags>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之 bind的模拟实现]]></title>
    <url>%2F2019%2F11%2F10%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%20bind%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文模拟实现了 JS里 bind函数的功能。 面向对象之 bind的模拟实现目录: 1 预读文档 2 bind 作用介绍 3 bind 模拟实现 1 预读文档 1 JS深入之bind的模拟实现 2 MDN this 阅读原因: 参考实现文档 2 bind作用介绍 1 Q: bind方法的 使用方法 和特点 是什么 A: S1 使用方法见下 12345678let Ex1 = fn.bind(A, v1) // S1 bind返回的是(即EX1) 一个this指向A的 fn的副本// S2 使用方法1:Ex1(v2, v3 ...) // S2 bind可以分次传入参数// S3 使用方法2:let obj1 = new EX1(v2, v3) // S3可以用new调用，此时EX1内部的this指向的 obj1, 而非A 3 bind 模拟实现 1 Q: bind模拟实现的难点有哪些 A: S1 bind只能被函数调用，如何判断当前调用bind的值 + 值类型 =&gt; 原型链this指向 + typeof S2 bind可以返回fn的返回值 =&gt; return函数 + 函数return值, 即 2层return S3 bind可以分次传入参数 =&gt; args1.concat(agrs2) S4.1 bind的函数被new调用时，this指向实例 =&gt; 函数内部this + instanceof S4.2 bind的函数被new调用时，obj1 继承了EX1 =&gt; 原型对象赋值 2: Q: 手写出 bind的模拟实现 A: S1 ES3的实现方法 12345678910111213141516171819Function.prototype.bind2 = function(ctx) &#123; if (typeof this !== "function") &#123; throw new Error('调用bind2必须要是函数类型') &#125; let self = this let args1 = Array.prototype.slice.call(arguments, 1) // 从1开始截取，去掉第一个参数ctx let fBind = function() &#123; let args2 = Array.prototype.slice.call(arguments) // 内部的arguments 和外层的不是同一个对象 return self.apply(this instanceof fBind ? this : ctx, args1.concat(args2)) // new调用时，函数this指向实例 &#125; let fNOP = function() &#123;&#125; fNOP.prototype = self.prototype // 外部的this指向的是 fn fBind.prototype = new fNOP() // 继承而不污染fn的原型对象: 临时函数 + new实例 return fBind&#125;]]></content>
      <categories>
        <category>面向对象 bind</category>
      </categories>
      <tags>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之 call+apply的模拟实现]]></title>
    <url>%2F2019%2F11%2F10%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%20call%2Bapply%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文模拟实现了 JS里 call和apply函数的功能。 面向对象之 call+apply的模拟实现目录: 1 预读文档 2 call作用介绍 3 call/apply 模拟实现 1 预读文档 1 JS深入之call和apply的模拟实现 2 如何用js实现call或者apply的功能 阅读原因: 参考实现文档 2 call作用介绍 1 Q: 函数内部的this 有什么作用 A: 先看下示例代码 1234567function fn() &#123; console.log(this.value)&#125;A = &#123; value: 12 &#125;fn.call(A) // 12 S1 函数内部有this属性 + this必然指向一个对象 =&gt; 函数可以(通过this)指向对象，从而访问对象中的属性和方法 S2 即 this可以让一个对象(函数也是对象), 高效复用另一个对象的 属性/方法 2 Q: call的作用是什么 A: S1 fn.call(A) == A.fn(), 即 指向函数 + 执行时让函数内部的this指向对象A S2 所以，模拟call的思路是: 123A.temp = fn // A对象增加 fn方法A.temp() // 执行fn()delete A.temp // 删除fn,避免影响到A原有状态 3 call/apply 模拟实现 1 Q: call模拟实现的难点有哪些 A: S1 A.temp = fn, 如何获取到fn =&gt; fn调用原型链上方法时，此时原型链方法内部的 this就指向fn S2 fn中执行时，如何获取到剩余的传入参数 =&gt; ES6剩余参数/ ES3 eval方法 S3 call不传入参数时，默认指向window =&gt; ||替补情况 S4 可以接收到fn的返回结果 =&gt; return + fn的return 2: Q: 手写出 call的模拟实现 A: S1 ES3的实现方法 12345678910111213141516171819202122232425262728293031323334353637Function.prototype.call2 = function(content) &#123; let ctx = content || window ctx.temp = this let args = [] for (let i=1; i &lt; arguments.length; i++) &#123; args.push('arguments[' + i + ']') &#125; let result = eval('ctx.temp(' + args + ')') delete ctx.temp return result&#125;// 测试一下var value = 2;var obj = &#123;value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call2(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; S2 ES6的实现方法 12345678Function.prototype.call2 = function(content, ...args)&#123; let ctx = content || window ctx.temp = this let result = ctx.temp(...args) delete ctx.temp return result&#125;]]></content>
      <categories>
        <category>面向对象 call apply</category>
      </categories>
      <tags>
        <tag>call apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[script defer和async区别]]></title>
    <url>%2F2019%2F08%2F10%2Fscript%20defer%E5%92%8Casync%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[本文比较简单，主要是对 script async 和 script defer的区别进行了小结。 script defer和async区别目录: 1 预读文档 2 defer和async区别 1 预读文档 1 defer和async的区别 阅读原因: 最佳参考文档 2 defer 和 async 区别 1 script: 读取到script文件时: 停止HTML渲染 + 立刻下载script + 立刻执行script + 继续HTML渲染 2 script async: 在HTML渲染时并行下载JS文件 + 下载好后立刻执行JS文件 + 执行完成后继续HTML渲染 3 script defer: 在HTML渲染时并行下载JS文件 + 完成所有HTML渲染后，才会执行JS文件 4 最后，一图胜千言:]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域之 从执行上下文到闭包]]></title>
    <url>%2F2019%2F07%2F21%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B9%8B%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%B0%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[本文是对 闭包的相关知识小结。 作用域之 闭包目录: 1 预读文档 2 什么是闭包 3 闭包的实质 4 闭包的作用 5 闭包的问题 1 预读文档 1 JavaScript深入之执行上下文栈 2 JavaScript深入之变量对象 3 JavaScript深入之作用域链 4 JavaScript深入之执行上下文 5 JavaScript深入之闭包 阅读原因: 详细介绍了闭包相关的知识点 2 什么是闭包直接看实例代码: 1234567891011121314151617181920var num = 10function addOne (num) &#123; var result = num fucntion temp () &#123; ..... &#125; var add = function () &#123; return (result + 1) &#125; return add&#125;let result = addOne(4)console.log(result()) 步骤分析: S1 调用全局代码，会创建 全局的执行上下文对象，即 ctxStack = [globalCtx] S2 进入准备阶段，产生globalCtx.VO + 执行全局代码 S3 调用addone函数，创建addone执行上下文，即 ctxStack = [addoneCtx, globalCtx] S3.1 addone函数定义阶段: 会有一个[[scope]]属性，值是 所有外层函数的变量对象数组，即addone.[[scope]] = [globalCtx.VO] S3.2 addone函数准备阶段: 初始化addoneCtx.AO + 定义add函数时生成 add.[[scope]] = [addoneCtx.AO,globalCtx.VO] 12345678910111213141516// 函数准备阶段addOneCtx = &#123; AO: &#123; arguments: &#123; 0: 1, length: 1 &#125;, num: 4, // 形参变量 + 实参值 temp: reference to function, // 之后的同名变量声明 不会影响已有的函数声明 result: undefined, add: undefined // 注意区分函数声明 和 函数表达式 &#125;&#125; S3.3 addone函数执行阶段：赋值addoneContext.AO值 + 生成作用域链Scope属性，值是 当前的AO + 定义生成的[[scope]]属性 12345678910111213141516// 函数执行阶段addOneCtx = &#123; AO: &#123; arguments: &#123; 0: 1, length: 1 &#125;, num: 4, temp: reference to function, result: 4, add:: reference to FunctionExpression //注意区分函数声明 和 函数表达式 &#125;, Scope: [AO, addOneCtx.[[scope]]] //addOneCtx.[[scope]] = [globalCtx.VO]&#125; S3.4 执行完addone函数: 其执行上下文销毁出栈，即 ECStack = [globalContext] S4.1 执行add/foo函数， 生成上下文addCtx并入栈 S4.2 准备阶段: 初始化addCtx.AO S4.3 执行阶段: addCtx.AO 赋值 + 生成SCope = [ AO, add.[[scope]] ] , 其中add.[[scope]] = [addoneCtx.AO,globalCtx.VO] S4.3 执行完毕: addCtx对象 出栈销毁 即: S1 定义阶段: 生成function.[[scope]]属性, 值是其外部上下文对象的VO S2 调用阶段: 生成执行上下文对象Ctx = {} S3 调用后的准备阶段: 初始化AO对象, Ctx = { AO: {…} } S4 调用后的执行阶段: 赋值AO对象内部值 + 生成Scope属性: Ctx = { AO: {…}, Scope = [ AO, [[scope]] ], this } S5 执行完毕阶段: 上下文对象 出栈销毁 3 闭包的实质1 Q: 闭包的实质是什么 A: 闭包的实质，是作用域链机制的副作用； 只要子函数上下文中的Scope对象里的 [[scope]]仍然保存着父级的变量对象 那么即使父函数被销毁了，也依然可以在子函数中访问到 父级上下文的变量对象 4 闭包的作用1 for循环 函数数组 内部变量的正确绑定 123456789101112// 例1：for循环var data = []for (var i = 0; i &lt; 3; i++ )&#123; data[i] = function()&#123; console.log(i) &#125;&#125;data[0]() //3， 定义并执行data函数时，其作用域链为 Scope = [AO, gloContext.VO]data[1]() //3data[2]() //3 改成闭包的结果如下: 123456789101112var data = [];for (var i = 0; i &lt; 3; i++ )&#123; data[i] = !function(i)&#123; return function()&#123; console.log(i) &#125; &#125;(i)&#125;data[0]() //0，定义并执行data函数时， 其作用域链为 `Scope = [AO, 匿名函数Context.AO , globalContext.VO]`data[1]() //1data[2]() //2 5 闭包的问题1 闭包的缺点: 常驻内存会增大内存使用量, 增大内存消耗]]></content>
      <categories>
        <category>JS 作用域</category>
      </categories>
      <tags>
        <tag>JS 作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之 原型与原型链]]></title>
    <url>%2F2019%2F07%2F14%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[本文是对 原型和原型链的相关知识小结。 面向对象之 原型与原型链目录: 1 预读文档 2 原型 3 原型链 4 函数和对象 的创建过程 1 预读文档 1 JS深入之 从原型到原型链 阅读原因: 原型和原型链概念的最佳介绍博文 2 JS中先有Object还是先有Function 阅读原因: 关于Object和Function的关系介绍 3 深度解析原型中的各个难点 阅读原因: Object和Function的关系很清晰 2 原型 1 Q: 什么是原型 A: S1 JS中，每个函数都有一个prototype属性，指向一个对象 S2 JS中，每个对象都有一个proto属性，指向一个对象 S3.1 我们知道，通过构造函数B，可以创建出实例对象C S3.2 构造函数B也是函数，所以当然也有 prototype属性 S3.3 实例对象C也是对象，所以当然也有 proto属性 S3.4 特殊的是，实例对象.__proto__ = 构造函数.__prototype, 都指向同一个原型对象A S4.1 实例对象C可以读取原型对象A上的属性和方法 S4.2 原型对象A有一个constructor属性，指向其关联的构造函数 用代码表示为: 1234567891011function Person() &#123; // 构造函数: Person ......&#125;let person = new Person() // 实例对象: personconsole.log(person.__proto__ === Person.prototype) // trueconsole.log(Person.prototype.constructor === Person) // true// Object.getPrototypeOf方法,可以获得实例对象的 原型对象console.log(Object.getPrototypeOf(person) === Person.prototype) // true 用一张图表示为: 实例对象、构造函数、原型对象关系 3 原型链 1 Q: 什么是原型链 A: S1.1 每个对象都有一个原型对象，原型对象也有原型对象，一层一层的原型对象就构成了原型链 S1.2 原型链的顶层对象是Object.prototype, 再往上则: Object.prototype.__proto__ 为 null S1.3 通过原型链，可以实现属性的共享和继承 S2 原型链的属性查找机制: 会依次在 实例对象-&gt; 原型对象A-&gt; A.__proto_对象-&gt; …..-&gt; Object.prototype中查找属性 S3 原型链的属性修改机制: 只会修改实例对象 本身的属性，如果不存在，则添加该属性 蓝色部分表示为: 原型链 4 函数和对象 的创建过程 1 Object.prototype S1 浏览器内置就实现的 key-value对象，它是一个对象 + 对象都有proto属性 S2 ES规定了: Object.prototype.__proto = null 2 Function.prototype S1 浏览器内置就实现的 key-value S2 规定了: Function.prototype.__proto__ = Object.prototype 3 Function构造函数 S1 构造函数对象 具有 proto属性 + prototype属性 S2 规定了: Function.__proto__ = Function.prototype，就只是这么规定的 S3 Function.prototype = Function.prototype 4 Object构造函数 S1 构造函数对象 具有 proto属性 + prototype属性 S2 Object构造函数 是由Function构造出的实例对象，所以 Object.__proto__ = Function.prototype S3 Object.prototype = Object.prototype 5 自定义函数的 实例对象 S1 实例对象fn是由 自定义构造函数Fn构造出的，所以 fn.__proto__ = Fn.prototype S2 自定义构造函数Fn 是由 Function构造的实例，所以 Fn.__proto__ = Function.prototype ，且Fn.prototype = Fn.prototype S3 Fn.prototype是一个对象，它是由Object构造出的实例，所以 Fn.prototype.__proto__ = Object.prototype 综合上面所有内容，一张经典图理解为:]]></content>
      <categories>
        <category>JS 原型</category>
      </categories>
      <tags>
        <tag>JS 原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2019%2F04%2F21%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[这周用hexo和github Pages搭建了自己的静态博客，这是过程中的小结记录。 因为主要是用来给自己备忘的，所以只是直接记录了相关的参考文档。 一 博客搭建过程1 Q: 如何搭建博客 S1 实现基本博客功能，参考这个文档即可: hexo教程：github page+独立域名搭建(1) S2 配置博客主题，依次参考以下文档: 01 hexo的next主题个性化配置教程 02 next官方文档 03 底部文字居中 04 代码块复制功能 S3 利用git分支进行多终端工作，具体可见: hexo教程:基本配置+更换主题+多终端工作+coding page部署分流(2) S4 发布步骤,代码见下: 1234567hexo cleanhexo s --debughexo dhexo g]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
